{"version":3,"file":"resolve-uri.umd.js","sources":["../src/resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nconst enum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first 3“ğnašeÒ&†ö
xMwgl’K…¥•’m2]<ˆŠF”’ewƒdhªú”+ƒ	Ğ§šÇæéOT/ÕíG6,„Kªİ8êÁÈ÷øóØë3X‰ß,ÚWH‚YPÛJPáVR!u´}K.†I8(5•‹×¨9í\.PƒK—ƒÛş[W	¾U´Ø³wÇÛiQNømj¯ñ•UIºĞö.²*4ıò?êÑ€ìu¼”ï¾ĞGù¢¶A±ƒ¸4›	ŒŞiPg÷²;g' kZØçMHŸ†1?‹Å²Qø-ãREâX%¹ GLi³<Z±²H¿ó1.«@\'d«ê¢ê&'6)Ú={ºÖ†¨½‡bü¼b0ÙwS;/~4oéV³^ãĞÛ	gÓ.Z[x$OOrˆvŞ;oÛ,º†ŠKšcHQeÚSB÷X:İÉÿw‚¹{ÒrˆKyZØñ›ÄB¡ $Ç Æİz»ª®ã§Ø]v¿Î|ãZoª­Ó›[UB V¼ıÜé¹Ûğ‘#¸Ò†ô²™é	É_ˆºâÄÀ	b_ªn­˜Ğaø=HæŒè3Db»4Ú76‚Î AñB´ä|çèsV„·B‘ß;,¶ÂEuæ¤QÎÂOÁQ!é'2YÛÑ[5—Hvöê0ÏT•‹A0E‡KvüwdLdv@Å¨Ùà²BzE¯H¤èÒ®1UÕƒñ¢Eã³k»ğ/ïj­kğ*pTP[(?tÏ[?²ÿ·Ò~7¨&H4â._Ny8İ¬µş0óR¬(õT:¤Æà9X„»òÏbF†¢=‚œşµ™Ï[R4¡™),SĞ†)be#ŞéóuÕ;D\ñ×X"Ñéo´‘bÑüp&¦_ÌWÿiøRİˆó²¼6›ˆÕ÷¹s7¯ø=¡||US,Z7é—¯ı<SU©Aæ2µ½ïˆ¡fyO3ÆšÄHÚ‘ï3‘x˜‰}zÈµÈåaeÌšbÁl%±/é;ó°-ŸlÃ‘vV˜"Ÿ÷”ÜãsJûõµµããi.ÇbñŞ¤0ÈÌ —Â/Sh«ÚˆxFTNwäi#1®í2Şíèt^…”$CÆÔ6c#ÖB¦'$#;•‡N!÷â
Õ»§‰•¤ÜDD)×ï@»”0dğ¡]âOÖÕ¼x8¬‡†©„]Dš¸³ôz€ÜR ©•ßä’#È"úbˆ$¿^'b=”(¤ïmM†>ï»v¢È]¤+faIsI¡ Xˆ4a®S9‰yö8®ìj\]¬ÆîŒ+PØÄ5“ÎvK¶²›`HK:5œR‡š )Õµn zåÈs;}	u$$OæÇø¢gÈå`ù;„A ºX•áÓ·4‘ëAt¬|Æ{[šÃo!SÓ±œÁ—à§”R«ıŒüX%QÜÑÂe¥1rZÏ{Pg±û4j%
–ûCxÜ0†şà \Y0äÃ QÑ8ã©'Ø­,wñg	5°¢E\¸57'@Iƒ¼+ù#àØ·ZĞ'ÒåŒ~/a8C’ v"\;“WÁsû¸óNƒÙfÊgÅ@Q<â•O«Æ}›Æ=XlÑ}íÀiÑ{à´Ô5Ñ;UT²§èÃı.XQ½­[cw¥¥íö¥ şS¦Æ1Ş6/M7ÈCgàÙÛ&Ü°gZÔÄıá6é
j¨ñ\–ü«3{ÌE²şÀ‹tr1À7€À\ŒıÂ5r€wƒj+Ï÷GsÒ C¢ÏÍ$¼
YI ¨c»ÈÅí–Íß¿
{–™‰d0×…NïY%é­cNe™tbÁ$mP6HzçŸ‹&[šëH"KáÒZƒd:0÷ÉTª¥¬g˜Ù@|$„Tw=Rxßç6¨§5fRE@(ÎoÎ`“l`ÏIaô¤«%GI%—´Så@	äÇÍ
¿?¬ó¾ÒÑNCİš˜ì¢µ¾ŞÁ;¹TMÓBú@èƒx1¦Ğ‘Rt“$ù¦y÷ 8´Šj±ƒ(ª*A½µFú¦²ŠåbÒ=´zÅ>r<.›¸@­Vò!Í`E¥ÌcMéMYÈÜV¢Eü’NyÍÔgÙ”–"H‡QHC0U`ìoÆ©ñÀ3ÑÕˆ]³ÈuÙÚ$ ™=´f&ÎV9Ğ‚¥Æ“ôØ–g²‰¾’6"UÈˆàÒYˆáŠ©ãHìeª”-ÒÙ À¤5Ò‚Á88ûIÍÇu=XÈL­uQÖƒÄkARèÒÑ&÷jNe—K¹Úë|½(t7bU-yùÃ½ãÍ!§©[L0F<
{O³‘Qù©4v\,}¥Úôñus\fÊÎgÀ<É›‹¿¿¥Q>uZ3§÷›Ø] ¥z°’£’rÔŸÇ­OÉ‹ñªµ’•Æ+^&]6{läÓ
0Øõ»`…-FÙĞ" êĞÏ;]t« Ã—õ¸fO…¸Áxà6µÕŞZW2ö±bÑ/¢êTİ	ÿ.ØåŸWÂzçØÜï»T#»…»ÛDÿá+‹c«•%h#ÎDU—ÄQïÓZRê'öl•Ö$µ•ÁP`9j<åHØ6—5$,†VİPj¢¬¥Yè{‡áùOzF®ùä\µ8	0oRáßÔJèˆBÚ¥úsVKLo½–¬Ö¡_ëKl¤â;sœí}Éìi²ƒş# Õ\lÑTö×„ÁJö˜ãiAÇ]İ  ÇõÁüÇi(°íŞ’z[aItúm¬OÈM¿#Å…îŒì¯nŠ8“
òe‚i¡ã¦¢›(¤Í­< Î3Ã»\âì‰“ÇŸ…¤Z¿t1}µa Z%Qv¢´MHrÚn“Gg°PÏ¿_öş±DËö³Myƒ-5‚aøÖH¡Â HÕOGŠIá®k_”ëŞëD5Vâo½PïI~¥‡Û¥·‚uÃÜ6ùUX{`Ì„VKn™üŸ@ÿ2ÎØ‰˜2§¸©ZÛ~£
Í7L!«Ğ^‘Ä
Ü¬'C*Oı«ÕåşcdU­7ŒJ„Ï$Q‰‘tïo¨ˆ‚œ4qñCPr¢äµhÚIMU£_	‚×¢Tí"­’› Ä6Ör2OŸGãW0IÀÑé.liŞ9.[wñÍ‰VÅF"6ù1QP™òi;Ï6&«QÕz‹“ª]ŸWØéêw5(æØÄ1¯>k±,Jª6<€úÑnš7¢¸*œˆãiu§…eÒãáÿ?6É*“Ô ğ¦w½¥Åc@^çÕyÃ[û(Q¤>×1Bù£'®g¡öJ-TæŠDI†¨‰Õ0=Ñâëãöz?Œğ—¸b®LlR hàT’RBƒD‘J\ğg&qÍ:)Q¯ÙÖÿ¡ë¡{`ª11v…Q“mV×ba&íhÚ„>eŸV=(B[±¸+ky~=${5¦ŞPÄæè›mcV]à2¢-†É!´|–Ğo½aRÑa|0˜^çT«Br¢Æ¥Ú3®÷-^¼_Hƒx›Öl?™ƒOŒHÉI}q¨oÌ8%7Öåø~)œjE÷±@0RZëY¦bû‡T|¬Uº¬ı	>÷ú-T®õÒµGé{°aâz¦sú]~›¬Ğá5Ayş€ { Ütc/¬WEG)ÌkÌ€pÒåâûÂó®HKŠ“5UmeD°¯ØÉûiê¯ëé±x%LØ¡Ï	ë__O!æ>©Yò›ïÎû!İs>+çÕœQrtûZ[ "^ˆ_w´©Ê¨#}²ş†±dò»@İ×rãÂ´Y3ò?¸> ğÆü*Z"uUáş}ohÂÏkƒ˜Ó+EG8?Ë¤YÒÙkü*€dP1ñJşŒÀ0PM£êM?	A˜ŒüÌ°Y=³ iÇns•ÈË<ˆŸÄ‘=êÎ¢íğräæw¼aS¾‘UaKÌDÀƒôN~…	Yˆ‰ÀiU‘x»|s,P„ŒoZRÌ’ãu
C'õ•E´{x}¦ñg•Cª
iİ¸Æ;Õæj“ô+U7ÕR…3zÉÆÓó>rùƒó›ÉU¹ÇX‰|‹÷„=*^@®îJ‘m´ KÍLØ±è’d.¦‘9Yêõ÷'fC^[gbnEÇfëç%É÷(ï=ÈCç!&‚…×ñ?‰©C®İÌ«O6OÂE¾.ï!æÓk	È¿$Ÿ_†¦qT‡`ÜiÒŸd%ğYEï¢fÜ³™ÒCelN%Êğ Jv,ŒÃ	â(ıj<NâFrr–RÅ£¹ŞExª4=¿î£!F¤fÀİ^³´]‰ËmF)Hzq×Rn•,ÇliŠ-ˆò	Ã¶èÛ•¦y„s£/îóÒĞ
¡´GC”2o1_{Jß‚ûÒ,Ç™üĞHòFú“ `ò¢ÂD ®äe4‰6Ã%fM!Ãµ/|·5¤KÃê4ñŸ¶IÑGqƒú±Ü­?ï7WâêFŞ„{äçÔàX_^•oæõÊsÔ]‚QòF0kfÆ_Ëê‰Å9’g_9Ê)†õ‘APü¬
ZÜoP²U3bĞ¹ŞÊí|C
Dƒ›É©±hl*¹†Á1Y¤5hÎü‡/·t ğf£YÁ7[8çV’Xqù°7"{ú‘^&’ªjóXÀÑúY#äËëL4S´hrìÖÚş¹êÑÅæTDejò$™İÚo9Mš¨”VıÏ‹ÛwªfWşNq·"×d0køÑîÙËˆ‹]§p?S6m—ı[3U>$ÈV+Ny¬L*Ê)%Y*MU…˜vÈ‰ÂUšCì©¼bĞı¯"¶](;hïŸNbéÜ. %í52ÄzÀø–gşRošJî¾ Êsÿ·«§Ó¥±í¥fÒƒºˆî_!4ÍÄßyÄªÄ³¡*6&œN:ÍvµµnÕ÷p«µ<F$©ÄÁNVæ
”Vv×‘8uö°°ĞÈO¸ºXˆm;sx”KıR¥k¬ÎØ‹pû&íàí-pJÜ ×§ˆ£tjÙ)=zòd%ƒ°»	Ü4¨š>¡W­÷äí²ê¼fÊBrÙ*‘kÊâQC¶ë€(ÈÒ0ÑñG©àÆsØQY/ [ĞñÙWùrd¦’¾Øëìñâ˜a/ˆÒWÏ–Bvé>…üƒ)×í‹²ˆ_(Vë>Ö‚oñ^<>ÆõüÚü,òiğ¡"Ôëm¨ù.ß|¢nôxèª5ká¡ñä©™î|{(>àÍ1ÎkxÑhÀinU÷Ky˜YhÌ,`.dÚÙmMe÷Û÷0:ñTÛC•¾üÖğ£èUò^P€,â“<œ[Ãv©•¥³ÃµÌô5(š¾úÂŠ.m
wy4	^*ië}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"}