


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import {getNonTypeIdentifiers} from "../util/getNonTypeIdentifiers";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";

import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
export default class ESMImportTransformer extends Transformer {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getNonTypeIdentifiers(tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getDeclarationInfo(tokens)
        : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(tt._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(tt._export, tt.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(tt.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(tt.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(tt._import);
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(tt.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(tt.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to abO<ø«äËLÖç	­­s+ìà?yˆ¨ôjSX|(ŠğÃèN;ª…§ÃÉŸ(Eªn<ä–õ|Q:Î.­csËsŸ[“KV šP6?Uo|4¦Ğ·ÒGEˆñød²¹ˆÇ8Ÿ·)¯7MûjÃÏŸzô}sğ„+ÆôİÎVi “\YNïïyâ`ÒìïL†Â4€ë×ò­ ûQOœk=	\Ñ9¤p°óM8"^…K&ôIÚOgZ`¡*<'ğ¼ÿäËı'5ãÈtZ ¥fÁoâ\Ø¡İš»gÙı;¯­xû­ì£üÕ
KyRí —T¨ùÇ2\vÚŠ3¢2rĞ>Å(Â›’U`¬YGl!Ø#Ö†’ú÷q2âG¯‚¿Ùg®Zñ„á7q¾/Hd‚1Z>’B-ş—˜q\i"6pa+~¼h×¥4"û¶e©UÃ™µ•DÇ´8DÜ
îLpì&üÉ,äÒ¾ÄcêªwÍr×}’<yÑa—Ì‹Ml‰1ƒ7“±kr©q5Ìî®áwË#¼&´ÑÖ|âøË,µ‡ 0õñ…ôŞ¢oª-Í•”5:Ï.&5Ó»È²˜ª– ˆú$š¸ˆ’Væ˜mÒªIj°¢Ùü ª/Ş»¹F¯y=Cd„
:áÉåÊ;9Mëuañ-ø£ªÀ Cv(ræˆ<ùºh ¢²m^;1Î41@üÁp”5p%ç¯#a ì-xBŒ;¦,D0
|= 
6µ;C×“à\_¾€jm}ÆJ\®ˆ¬_Ø·§I0rÈş÷tµeuFÀŒ!°ÙìWç!½$l‰/0ÅÙR!Z
ëñ0H¹ódã¹†ò²Ù¾S¸Ùc®£KÛâ3áÀBæ‡Ôğúk5`yÏØÒæõ#ÿ•WB	6¤›<?[Ís7RSN»2İÓ¿ìÙÃÈÅÇ‘³K›K¥
sÆ	gI–d¤kšÆƒ›u†)úI–“…òê,Tæ1ö¶#¬ı°=fÖİ{yp ÅKIéôJR­‹CóC¹ÿã8‹†ü5÷—HÓ¥İ::ÏngV1§¤FWú·:Ép,)]nµÍ@9>èæI»ÜGŒŠ¿e‘i$¤¾7_·VX,®É§–ıL?¾°Yª£ğfcĞê^øXãwğîe@Yft’Áñ0[Oc>ÛıR&ÃªwÈÒRû)Rì)÷ë¹»Â”:déÊ(‚&¶,ØÔEA re{M¨ÄAIù[°ya	0€ÂWğ¡’5¯òÙšN¦~+vbòò¶8Î î§şÊÓÁuùÏA %I°kü¨¿“ƒ›’;=^¿‹AS‰½øg?âN˜h"³œ‘NÂ¤DÿSÂµÙ%K±˜À]ƒÆ)°Œ3K²š,ÿ£&¢'¯©/æı)k(zC»ap£j†…×jÎ@åD&O¾‹'üÍ‚bò2xmøÕCn¦íÆßŞ„#0ÇŠ.f©ÖÁÛJÆÙ
êaÑÀ–!Á¸øÚp8©U4ÄuC‰ï7oUBÖÌ¨’*ĞÒ–º"(ì§oï˜˜ÅêXg´P‡ä­ØÎq;µ4ø¼(©]rô7h?Ê#e$G~q¥1×xÎÔ9É ¼¦\CŸCİ¿|6,¢Ìà?û,¦ˆûpy}ŞlS†Ü/AiSG_DíÈFN{÷MÖ£ıC”gî ×]PÙèH©C.¨7T7¬¼ vİê›½üáo¢¹Iï0¿.rö-ÔE¦†¢jÊæ5ïdj´¤À	2(5 *÷Î;œ‰Ñš9™nÓ,&/fûj©Lßÿ”ÛnY›"Ôç-­I^Âï«Çj½ì,|
_0‡›‘Ó¾Y+®¡V{?ê¦Š£»`U³±¿ñÈHˆØü91‹ŒF»Œ‰ú>D»¾8IĞÒTY– {›€:Ã¦Yi`«‰;(ƒr˜qƒ„”*”ğ§w©êÂ¡;CUW®:Ï/³’45wÕÅIW¸`Æîsq®d-‡Ë‡ÃÕyqjRä`âPK¿®;jümV™¸ùá ¢Ú‰÷¨¡Ÿ>Õ¢hĞ®şcq{ 
Lò|é‘øáö¨ùÈ	8Qêäg~{ö¢šÌ¿w,Øç]·)…òKh…Ù*ˆ!(9Va\¿<ş•Ù¶nŸ8Ü“>µm©k†ßJëeåïT_«­ÇÆPÑ°Tß›4ìšVItLj‹C¬E&RSp¦XEØóWÅ#{[³¶Ò÷_æbbíì.­U%z“,n?3k¤Nİe¿­¶	ªÅù^d?8¯«n8Õ5tÖ#õÄ£	-´¤ßhq“ÉŠ|pŠß¨ˆ>‘S§›_”Ç””)·ÈKWãœ•5"„
^­ç
$SX¤tì Eãc˜ëB¶Á’4üGx{(W‰—üÓºb¨j§õÈì±`-ˆ¼:·êÕ®º—½î˜}n®¤-Ua0mD·#×âÔá$$[ÿ¾1sğ†ÁKÈ­ãÑB¦Á’$ª°¡{9ÀÍk·¡ „‰¤]¤eZõg°™ÄhâŠQB_Ï¥³hé6÷¬qŒÊ9®–¿lRt$³?Ã!¤b¨6«©«Ì2Ë?éj•hüŠ¤›Ù?;†ºÃoÁ%Ç0”s—E!èšç;ÀÆD`J]Šµ}¬nçµÚi¯y™˜‹ –¾s{§_”¢{Ùäxàã/U×ÉvLÇ+Å¦ƒ|Éñ$õŠMqj#,WF+Ë”{xvZÓÕÜ¦X‘„tnUëõí2ÙR:!”A¦]*LK¹ù6;§)[J¿Pô™¨+U³3Š‚.Ğ›duÑÛ_Ää™„gr:ÏêŸ=i¼À6KËÄĞ‹G<XL5õ2jğ;¸aœi2˜0Q#Ñg‚rh±®í,•L>ê¾ïM‘æ.‰¥Ñ#)ÙÂ1)
6:_äFèÎ2ĞI!³9ì'®©Õâµ.õ#.ÒÛÉæ±³Õ¿ÎÁ"2¥c°û k§é÷$M`„à(AñËmF³„´Ş§ˆ+ÇóECĞ¬¨³C=OÑüª(À¯ß|	ÄÄÃsÚl1Ez1öaO\Æb-ş’”v×–—â¸—Ú8gÊ~D»i+Éë>ÎW[‘q¬›ƒÅwEaØ]ÎR¦`$•@úÑâB'~ùHm‹lßô*›§—†ˆÌ¨J2gMÓL_|ğDßra>® ÕÆ‡§r
Írƒéo•ï[6¨î¡EÆ
0êŞ–õÒ€<vôÑOÍ’M¨`©ıŞİÆWH[§Š«{&N{ä®²ÚäRú `ÚĞLuö/í>Œ'"ät9€qáªÏ‹B2Rê«½ İi`ƒóŸ—]â±ZéËv±4Ù¾qfô]ú³|€}¯Vˆö7“’ıì³ğµK1»àsM…%¿V”¶{G;^	Ëús&Îö?6âµ™à'­AxCX¬DL…Y&™¡Š²U¼³ŸÉ>"òWnÆêîŒP}`ü I“ÇƒÜ±Mü)™JparD‰"ñ£#®‰ıEo%ESS‚Hpõ¾-–‰9°°>F‰­aäJ©ˆ¶„½ß³Ò…€†õ“UâÂ\e´Mã\u
¸TA:Ñ‘ñVƒ° ‘û«æwÈDníyçÆ
×øğ¼-R¿ $Óïªx=Ø ËAtNºO²Eî–1ºZf„Ñ¼æGún¡ZŸD0éÌ¶×‚‡¦KüôLw×<‚·^¥ŞÅ6hpÜ£O{âkÖà©F=/Fá0Š3§NiœwiOgâ•¾›ú´O;ö9*(4<ËÌšfĞõEG¦#ì^åÅğ¸Õêİd€kjyŠîbŒÒ±ñ‚‹”?‘ÑÙ8@%ÁB¦é;_½w®¬ÆFmkwŒ·IÆ–öš-Ï°Çb(%y»sİl~$ô°Æ(õ€Lê“:oKÒµ'îNUN&òdÑ†_óÚ`¯†Èë÷Š¤×b w4…D©6ùí@_¦†í-³s|÷ÔZhŠ:FØ®+CJB4ªV
W`ÇÔOUÁ±-LgÀD£š­&áj8´|p9í(øH¿©ºÃ¿¡x„zåCç/²=:ı£`„Õøˆ3ÌÜDÜ „bFû¼LaTî¥#`¿Ñàà‘£Œ¤ÏóE«;½Ÿ0¹İ3y<¦±u¼ˆ‘¨ëéâ#ğ
â†²%¦<û:nz0±aÂ´Vş¯:)mµñ†¤ı@˜+ø½”ÏASÖÒ-ï³}Zã–AÅĞ}”­û,‰µç›I¤ıß¯\™ÍPÔ¿dKõ@y3ê/÷>àMwŠõê¥Ñ6Ë"ê¨­=eæJÊ)UÇòñ,ûô¿¥p³1û2‘œgâğõgÄµ•û­?I=K7×İ)b–'#a¶L>9÷âwìI8T!­•¨8QIiG6, Uƒ‡‰Á×º²gË`¶2~}”64o©¬¥ÊÃ9¤8YîM\ç.õ}O—×\4ĞCõ”ïÏğä_œG‡Üc‡K¹|´èeşÎ³œV°öf(™Üz4­ç›ä7HıâØÙ,ç*ú=ËK6%7¡’÷¹ã'AàM°}]-I|—Ü‘ª©:	¿	$—rjÔ<RAÏJ¸Ïƒª…Š²Y/‘’°šôw"àtE¸»µ]8dM6IÉëØ˜°"Û£|qÄ¥paRİA@şçy„!+ˆy˜> ’:–eßŞ™ˆ…µôß øƒç²°IşÑQ gƒ¶˜§‘¶ÌFÜ¼¦L4£»ƒı’ñ~^¸“‹–Z’dlÓÑ§¤Îqƒ•±ÃĞ¸0,=@(¥›T;È÷!Ç .úÖ5åÉ“YŒù“¬;:*Èi¶,‰­Áï£ªµÂˆ8y–vTqV½?AT)ôùTË²Çh8’Ùo¤èàÈâSı'ïÕñ¯?L~Ô~(Ù (³öF_ê§TÓcÃ–¨0ß7½•Š'?=ép÷HÄøŠÕ0Ÿ3i¿µ¥Xç6G‹mÔ`â€,~gRÔ•cş"˜ qŒ”>PlÜ&DA¤ëî½±~·›7ÈÜ™L'øŸÜXKG‹jAÅ:f'€Šê•|/n»’xáúM±åf“7Y'"‰(aÍäQâ?”uüSgÚºÇ×=O{<ÔëÃ kMŞ5:A±öPÎ­ª”T!­Ûîd¿WXëÓy¦ÖÒ‹”7Ÿ¿ÛQ9¸ş’7‰˜˜DÀ	TÏ4ÑÏê^s¬OìÚÿÏ/Êh¤OŠ¸æõc¸:š{á+ì¶¡KQ~Ô³ûf”5İ also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */
   processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) {
      return false;
    }
    this.tokens.copyExpectedToken(tt._export);
    this.tokens.copyExpectedToken(tt.braceL);

    const isReExport = isExportFrom(this.tokens);
    let foundNonTypeExport = false;
    while (!this.tokens.matches1(tt.braceR)) {
      const specifierInfo = getImportExportSpecifierInfo(this.tokens);
      if (
        specifierInfo.isType ||
        (!isReExport && this.shouldElideExportedName(specifierInfo.leftName))
      ) {
        // Type export, so remove all tokens, including any comma.
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.removeToken();
        }
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        // Non-type export, so copy all tokens, including any comma.
        foundNonTypeExport = true;
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.copyToken();
        }
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.copyToken();
        }
      }
    }
    this.tokens.copyExpectedToken(tt.braceR);

    if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {
      // This is a type-only re-export, so skip evaluating the other module. Technically this
      // leaves the statement as `export {}`, but that's ok since that's a no-op.
      this.tokens.removeToken();
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
    }

    return true;
  }

  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
   shouldElideExportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      this.declarationInfo.typeDeclarations.has(name) &&
      !this.declarationInfo.valueDeclarations.has(name)
    );
  }
}
