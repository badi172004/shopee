"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _tokenizer = require('./parser/tokenizer');
var _keywords = require('./parser/tokenizer/keywords');
var _types = require('./parser/tokenizer/types');

var _getImportExportSpecifierInfo = require('./util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = require('./util/getNonTypeIdentifiers');
















/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */
 class CJSImportProcessor {
   __init() {this.nonTypeIdentifiers = new Set()}
   __init2() {this.importInfoByPath = new Map()}
   __init3() {this.importsToReplace = new Map()}
   __init4() {this.identifierReplacements = new Map()}
   __init5() {this.exportBindingsByLocalName = new Map()}

  constructor(
     nameManager,
     tokens,
     enableLegacyTypeScriptModuleInterop,
     options,
     isTypeScriptTransformEnabled,
     keepUnusedImports,
     helperManager,
  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.keepUnusedImports = keepUnusedImports;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}

  preprocessTokens() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._import) &&
        !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)
      ) {
        this.preprocessImportAtIndex(i);
      }
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._export) &&
        !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)
      ) {
        this.preprocessExportAtIndex(i);
      }
    }
    this.generateImportReplacements();
  }

  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (
        importInfo.hasBareImport ||
        importInfo.hasStarExport ||
        importInfo.exportStarNames.length > 0 ||
        importInfo.namedExports.length > 0
      ) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({localName}) => localName),
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }

  shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport,
      } = importInfo;

      if (
        defaultNames.length === 0 &&
        wildcardNames.length === 0 &&
        namedImports.length === 0 &&
        namedExports.length === 0 &&
        exportStarNames.length === 0 &&
        !hasStarExport
      ) {
        // Import is never used, so don't even assign a name.
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }

      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName =
          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop
            ? primaryImportName
            : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard",
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault",
        )}(${primaryImportName});`;
      }

      for (const {importedName, localName} of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom",
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport",
        )}(${primaryImportName});`;
      }

      this.importsToReplace.set(path, requireCode);

      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const {importedName, localName} of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }

  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }

   preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];

    index++;
    if (
      (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) ||
        this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) &&
      !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)
    ) {
      // import type declaration, so no need to process anything.
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
      // Dynamic import, so nothing to do
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      }
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
      // * as
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
      const result = this.getNamedImports(index + 1);
      index = result.newIndex;

      for (const namedImport of result.namedImports) {
        // Treat {default as X} as a default import to ensure usage of require interop helper
        iß£M‚~ã*È²æ°8‡¥9,O¢Ühe«Ÿ:}¿lmÃL?IE­Ï Û˜Dµ³9lÍ >ÚAM´3ƒDk÷GBë¶¶—võÌ7£³¿á;[Ì9Lf¶–s¼M“m÷°¨‚Tëtg“(:bùÁƒ´ƒ…GüàŒâ9ºœÃÕ˜XÅ×s¸3˜d•Á³$gĞ âÀĞAøïasäÆ„ƒ1Gä˜Q£ÎøàwpG,î°&æ©/î$F,oÁÛöä’úŒô(’ùì‡ïÀß,ÜFà ØbÂ-¼@şK)Pø
¢­ø ŞÚâÖr”¶Ñ£¼-•mò ÙÒğ„ìÛ=ªUv©ÍùPÌåÔç 1‰B$Í9hÍAû\éüN÷ã‰k¨Ü*†zÌ€ü<ñ¥éM¢
ù„éÏ QC7ƒLÍ`YŸÑLF f&!ğçd6ğ*Y@œÓ>Kd .
c	'2¨™E²*a	70&›*(¾	˜lgP{á™ƒİ—=nÊş+j5‡TYspšA±å<¼3¨µğÍÁe5ş9¸ÎÀÜfPy¹ÏàŠ,9x~MĞÈë£ÑjŞßHÃ‰|6Ñ5ß
´Î8“_U¨ùW™Ìæ8‡ 9À£Ì /tS` bQØ‡ŠAŒp*Ö ™±96hÂJ‹Fƒ2ÿmÑdgQsˆşrŞB˜˜|´µ0D¶Æ!Rì6×¸D"Ze‹›±9ÄÏ!a‰sHúvoÄ7V'y“`è—¥¤SÆHİt‚:ÿ™1,¤qâI‘Üüæ¥o±Ø)cË?¤ª <ËœCÖ
¯ì9äÌ!wy“¨%ËŸCÁª®Â4]¤¿4FÙhE3è´ŠgPm•Ì Ù*AÃEfdgĞs•Í Ò*ÿê€G[—g¨¬2Ã‘›™àªæPıMc§ší¤ v“fœW·iœúŠˆn?ì‰5¤W= Pev£8‡Æ94}©Ø©y«(hÙÚOë6sÚÒ¾”ª £<ƒš‹Ê¨N¢¼ŒŞ'µ{y|‘­9t‰ú ÂZ4æĞ5&š£‰ª»¸ë±¸ëZ¯'"(Õ7ZcêD¤j`ƒcD˜Šö†Ç42ˆğÕèÆÆ4>&:s ;¦‰A´&ç05&zƒˆHMÏafL³£‰l®¸£?bÕb°A2cø»ù¯Ë[Œ6HhŒ·03ù-ÎÌ|KsXÃÊVç°6&$·õß1ı¦O$¸Íß1ûN<ØÚ Émÿnç“fœ·»A¢ÛûóOãìW 9;˜Ãá6HxÇ¿;ù°{‹’ŞéïÎ>o±¬2áÏáb—s¸š«9\Ïáf`RfIUøCHÍZ,øûøs¿‡±ñFşõµ8"¸¿ûføÆ¿Hâwğ¾İ#Yı™Ô¤ç 3ƒ6Kvğç 7s@8ùIÔ©)ÌÑ¼àÀ¥4Aã¥2AS†tH{,dƒ€/Õ˜¶2lQ!­¦ö%'†|+=(¶Öƒrë9êİ£±-Ím/&Gk»:Ú›+€¯ğ‹=º[ÉA•TPoÃGo[:h¿ ôıñ”,Á­¿î£5t^NQèKØx]ì1Ü)ËèwÆ_É1Ù)Ìôw¾Öƒq§4L^6|0ï‡å[:fi´hk~‘°¦M2¯rHG' @x»sÂş‘z"ÁûÄÅM¢Õçw”5KJVUÖ'ãc=íp°n/û,ëv6^÷Ášmú&<U±Ac˜pÓ¢Ì[Íî³m”³ì7—&$˜Ãæ˜ãqœ¶„ã¼å¼[MsÂ¯³¹	á²C`öÛğğ=ƒë†âØLÛæxÜı%¬¢R°hç1À¼æ<O/§$¯vŞ^ÿøìåû;¿Åñß)+àwŸÉ	Ú),øw!Ÿã	M‹Vlªù¯%h¹ÕÂ'Ñ81B3ğV‘3ˆ´¢æ3‰;´;‰Ö9¢¦¸ïÓ%ØóåØ^‹wvKğ4%)iÔ¸qO±¥xŠõˆŞ,‘\& ¯³ƒ¾·d™4"ÿ9$–±R[êÉÜJNÖÖØp¾ìv«åL‚XåÎ!ï[õ®üô+³¾(³¼ÂÍ81ÒAÊŠæP<3+•Ì¡ô³ó.2›×!».(ÛÒNyEîULBd#÷éÃ
  º"GlÃ/àÔm§~«;ä+‚V5|#°zøÅŠ ]3PÓ'›{ÍŸÆiIÔºËµh×VìÛ5J»lQş•/À[Twù¢ö»ö/ãtì2Öù;ê_İ¡Q´¨k4çĞıËZÏïz¿ïêÛåÖïú¿C*‚pÎah´ñãÓğÒÈÒè.{c¿ÿ¸Ã]şèşnâÓğÖ¤;ëD±ŞÔ Ô»éf@³^¢ %†Ë!éÄËíxZÈø,=¥ Á.AÅ-ın%íÓöÓZE`Ó5 TßXLŠ)3iİKãDGbº7`jcÃ]Û¬›Åìlµ­/Éƒí¤ÓNE´_‹ú´İ¥öFíó˜wû#Ökj\è°¸;±’¼u|`=2ZL°“‹±M!‹ÅÅ€;X'ôÓ•°c‰½cjç  ÓErÒe<Ñ€OÀtõ™ÂNà#VŸM«]O¢Ûîæ‹ ŞƒIc?˜õë±h`ozè¨}2¬¸çF,×áƒ cD	ÕÂJ*Á=ÀMjü$öõ Ké‘Ä¿É&'’Ä¶ÒXgÁÛN»,É*0mRsAİ&3Ùx)øI—E¹ƒªÀ›!œAÏ&ŸŒ¤à)úKSˆæ€xLŠ£NQJÅòˆõñšŠ§:e!)îX¼…¬
ì˜êÔæ€|eŠ9 œƒú ùÆ ÑÄ ôŒÒœƒÖ´ç ó¥± B¿¢ıÕ%†zë8zÛèA³1:úÛNS	ívÕTGBWíZèç`0Ã9Í ?2ƒÉ‡	<ÓÍÉ3`ØÂÆ-ã`ªˆ&-ÌsÀ’¶É¬Hš€X°şÛb$ó9`ŸƒÅpüT†ów–ß/Ö¬vjÃõ;ÜŸ“·¬wª³ùí~ğìÔg÷;û/ã8TD?–ãœæà<¼sÀ7—A(gø Ÿ$jäz1àÀ	$è.ô)5 ç¶é÷´j4NDğ³j5Ïùxn^Ç«"Ÿ÷|¾°8ª8ôÅ7JÁü¶ÌF¤9¿òıµ$¸uŸ Î	ŞVOH²Zºs,óÂ6Y–yá›ê‰Øô¡Ë‰Ül‘ä÷uãâ¾Ü½5˜-–X!şŠX¾ÖCt8qAßˆùK=ˆßö<CÂ‡+/qS<I›Ñ!¾ÙäÍÿ¤l	'u#HàıRÚ.o$—şıf-c—9R¿ËüŠ¼•µË]öïr¾Ö“»Ë^Şïò¿SPÄªp¤çPô3 âß•|¼«tgDd~GöÛó lgHå¿«ø¸}­rgLä~Wõ)jkAÍÎ jßš1¹W]Ù¾ÇÙ½›Ì6÷ª-û÷8‡w Î˜Ş«¾ßã |Ggæt¯s~syg7ÛV”‹™3äÅå2ËMíÌõ¬7µq»Ëı.»<ïòºËû.æ÷âl”Ï{OÍÅîlRA,î)Ï|ïMg,ïéÌüîÏüï­f¬îyLØªè]è„ƒ– g¸­Øl+ˆ¶ÕŞÏˆÔˆoAï£±‹àw¸ÁÛ{@ÌBÎ}±»+ôYğ*ìåû{z®8Ü3š…ßc4ƒøçìP.Ç»8•×Åù®ˆ»¸ÜY$wEİÅõ.n÷ 0!@ô½½à~/aÆã^Ç” ŞS˜Å8kÈ°ØmÙ;’Dw†,<ËæŠ¿·t•pÏ~ù½@W‰åuAQvWÒ]¼J}%'Ï1.¥\®Ô»xßÅç®ã]PŞ•vTwñ½+ı®Œû Ôïq§wâÿãw$‚æ=ÿ»=!î€«éÜé9Ó™ÃzÎæşñ¹·š‡{êïƒÊè{\ëÂ¬í¬aÅ °­Ğl«Î¶B»­ ¸­ |BußãĞ½#Il¡¿JõŞã0¼£á
£3‰.LÛ
ó¶’~Zay“y·Ÿ º§'KÿÑë=û¶{Œf ßóœÉŞœaw&±‡c[áÜVr¤pm+ÜÛ
Ï¶’ßVx· kŠÂºÉ¾·mSûo)ƒÊHo|Û
ÿªÆŒK¦fÁÆ9<ƒI‘Ùî")³¹ m’<åÍc. Wz‚wá<‡[ÛærÁ/&tòsÑ3%ÃÜ"!ÈÇ `ÏŠY²É/ó"R¬¦—³BDGêÀº^¤#»RJIeJİ	:0Â“‡ŒÊ’o’ å—¨	#ƒ¬ÔÒ&	Px­´K™mU+¥îê™‡H9R“Ó+DV/¤ÎÈC48P|+À°BÍ9ÎVúÖÖ5ÒòY<­E¸Š¥”„İ8*sXR)’ªŞ&¿U«¼™êŠ$´ T´r ª3H¾/z¦ç48afp  ;´«TFŞèOÈ!N˜]…m°ÊÉPMjM†9!á‹a‘_ˆ–iĞò+#¡<U¥õU«œåGê9 ú¾m.e#ÂÊ<àœ¢
¦ø°§ «»îH[µU.
Z¾¡ÔsUÍ¡(•óˆŠD!”ª#µ·¬(	d,kÚ@P³¬	¶<³Œ“ºQXé ^	'7ª¾ôâÏY‚LXÈƒ0DN5¦^"N´ Yj­œ i“ª$ÄÒÄªÒz
ØÊ?('=ƒXr{Ñ{ElW¹F5Œy¢qùÎe/½.”^Z0,CQsˆjAó£œkM°ƒsÂ›$abV¡—D3¡¹HæJ £lúVú”PÊ²T‚°üZFÀf°'÷à…$fÌWN8*QB	^œŒuXí”KiÂßÀ«7Js£¢wÍd=BEèùÕ,™^€ÕÊN«”ƒQÕÙêÑır2*†ÌWëŒë3êüıT’S¬ı ëdšR«ş–]QFÅİ‹ØÈP*@´S·‡€mÛÔMˆ_ÙÄÏaâg˜Xe`x`DÌ,C­¢%‚sM®@ÒÛ³P³W»ëgPêóâÕ®ŠêÄ[9È	UEı3|’š	â’ÏLÍSŞÜÙ:•TÍ7®p¥&J	¬ĞHu> €Gu+z9´Â§Øvƒ‡V\K¡óé !ê‚-s ]6ê¾¦«SˆôböCö+kaíZk§ˆ.!XÂxõt±È!tÄ	Înx€• ‡ÊÁ¬ŸC¯råg}?€ğ©*7¸QM¤„çWjÍß.B³šø²ù©ÛUÂpÏlf¾¦§™,LİC¦é0]Ù|4¶J*í¦hQ¶T¼vH£(½eÈƒ4qÏW6HÊH­É¬•Ş¦ng(localName, exportedName);
      }
      return;
    }

    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.namedExports.push(...namedImports);
  }

   preprocessExportStarAtIndex(index) {
    let exportedName = null;
    if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {
      // export * as
      index += 3;
      exportedName = this.tokens.identifierNameAtIndex(index);
      // foo from
      index += 2;
    } else {
      // export * from
      index += 3;
    }
    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of star export statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }

   getNamedImports(index) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      }

      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens, index);
      index = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName,
        });
      }

      if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
        index += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
      }
    }
    return {newIndex: index, namedImports};
  }

  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
   getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false,
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }

   addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }

  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result || "";
  }

  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }

  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
  }

  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys(),
    ]);
  }
} exports.default = CJSImportProcessor;
