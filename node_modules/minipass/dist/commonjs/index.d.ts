/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import { StringDecoder } from 'string_decoder';
/**
 * Same as StringDecoder, but exposing the `lastNeed` flag on the type
 */
type SD = StringDecoder & {
    lastNeed: boolean;
};
export type { SD, Pipe, PipeProxyErrors };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
export declare const isStream: (s: any) => s is NodeJS.WriteStream | NodeJS.ReadStream | Minipass<any, any, any> | (NodeJS.ReadStream & {
    fd: number;
}) | (EventEmitter & {
    pause(): any;
    resume(): any;
    pipe(...destArgs: any[]): any;
}) | (NodeJS.WriteStream & {
    fd: number;
}) | (EventEmitter & {
    end(): any;
    write(chunk: any, ...args: any[]): any;
});
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
export declare const isReadable: (s: any) => s is Minipass.Readable;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
export declare const isWritable: (s: any) => s is Minipass.Readable;
declare const EOF: unique symbol;
declare const MAYBE_EMIT_END: unique symbol;
declare const EMITTED_END: unique symbol;
declare const EMITTING_END: unique symbol;
declare const EMITTED_ERROR: unique symbol;
declare const CLOSED: unique symbol;
declare const READ: unique symbol;
declare const FLUSH: unique symbol;
declare const FLUSHCHUNK: unique symbol;
declare const ENCODING: unique symbol;
declare const DECODER: unique symbol;
declare const FLOWING: unique symbol;
declare const PAUSED: unique symbol;
declare const RESUME: unique symbol;
declare const BUFFER: unique symbol;
declare const PIPES: unique symbol;
declare const BUFFERLENGTH: unique symbol;
declare const BUFFERPUSH: unique symbol;
declare const BUFFERSHIFT: unique symbol;
declare const OBJECTMODE: unique symbol;
declare const DESTROYED: unique symbol;
declare const ERROR: unique symbol;
declare const EMITDATA: unique symbol;
declare const EMITEND: unique symbol;
declare const EMITEND2: unique symbol;
declare const ASYNC: unique symbol;
declare const ABORT: unique symbol;
declare const ABORTED: unique symbol;
declare const SIGNAL: unique symbol;
declare const DATALISTENERS: unique symbol;
declare const DISCARDED: unique symbol;
/**
 * Options that may be passed to stream.pipe()
 */
export interface PipeOptions {
    /**
     * end the destination stream when the source stream ends
     */
    end?: boolean;
    /**
     * proxy errors from the source stream to the destination stream
     */
    proxyErrors?: boolean;
}
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
declare class Pipe<T extends unknown> {
    src: Minipass<T>;
    dest: Minipass<any, T>;
    opts: PipeOptions;
    ondrain: () => any;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
    unpipe(): void;
    proxyErrors(_er: any): void;
    end(): void;
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
declare class PipeProxyErrors<T> extends Pipe<T> {
    unpipe(): void;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
}
export declare namespace Minipass {
    /**
     * Encoding used to create a stream that outputs strings rather than
     * Buffer objects.
     */
    export type Encoding = BufferEncoding | 'buffer' | null;
    /**
     * Any stream that Minipass can pipe into
     */
    export type Writable = Minipass<any, any, any> | NodeJS.WriteStream | (NodeJS.WriteStream & {
        fd: number;
    }) | (EventEmitter & {
        end(): any;
        write(chunk: any, ...args: any[]): any;
    });
    /**
     * Any stream that can be read from
     */
    export type Readable = Minipass<any, any, any> | NodeJS.ReadStream | (NodeJS.ReadStream & {
        fd: number;
    }) | (EventEmitter & {
        pause(): any;
        resume(): any;
        pipe(...destArgs: any[]): any;
    });
    /**
     * Utility type that can be iterated sync or async
     */
    export type DualIterable<T> = Iterable<T> & AsyncIterable<T>;
    type EventArguments = Record<string | symbol, unknown[]>;
    /**
     * The listing of events that a Minipass class can emit.
     * Extend this when extending the Minipass class, and pass as
     * the third template argument.  The key is the name of the event,
     * and the value is the argument list.
     *
     * Any undeclared events will still be allowed, but the handler will get
     * arguments as `unknown[]`.
     */
    export interface Events<RType extends any = Buffer> extends EventArguments {
        readable: [];
        data: [chunk: RType];
        error: [er: unknown];
        abort: [reason: unknown];
        drain: [];
        resume: [];
        end: [];
        finish: [];
        prefinish: [];
        close: [];
        [DESTROYED]: [er?: unknown];
        [ERROR]: [er: unknown];
    }
    /**
     * String or buffer-like data that can be joined and sliced
     */
    export type ContiguousData = Buffer | ArrayBufferLike | ArrayBufferView | string;
    export type BufferOrString = Buffer | string;
    /**
     * Options passed to the Minipass constructor.
     */
    export type SharedOptions = {
        /**
         * Defer all data emission and other events until the end of the
         * current tick, similar to Node core streams
         */
        async?: boolean;
        /**
         * A signal which will abort the stream
         */
        signal?: AbortSignal;
        /**
         * Output string encoding. Set to `null` or `'buffer'` (or omit) to
         * emit Buffer objects rather than strings.
         *
         * Conflicts with `objectMode`
         */
        encoding?: BufferEncoding | null | 'buffer';
        /**
         * Output data exactly as it was written, supporting non-buffer/string
         * data (such as arbitrary objects, falsey values, etc.)
         *
         * Conflicts with `encoding`
         */
        objectMode?: boolean;
    };
    /**
     * Options for a string encoded output
     */
    export type EncodingOptions = SharedOptions & {
        encoding: BufferEncoding;
        objectMode?: false;
    };
    /**
     * Options for contiguous data buffer output
     */
    export type BufferOptions = SharedOptions & {
        encoding?: null | 'buffer';
        objectMode?: false;
    };
    /**
     * Options for objectMode arbitrary output
     */
    export type ObjectModeOptions = SharedOptions & {
        objectMode: true;
        encoding?: null;
    };
    /**
     * Utility type to determine allowed options based on read type
     */
    export type Options<T> = T extends string ? EncodingOptions | ObjectModeOptions : T extends Buffer ? BufferOptions | ObjectModeOptions : SharedOptions;
    export {};
}
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
export declare class Minipass<RType extends unknown = Buffer, WType extends unknown = RType extends Minipass.BufferOrString ? Minipass.ContiguousData : RType, Events extends Minipass.Events<RType> = Minipass.Events<RType>> extends EventEmitter implements Minipass.DualIterable<RType> {
    [FLOWING]: boolean;
    [PAUSED]: boolean;
    [PIPES]: Pipe<RType>[];
    [BUFFER]: RType[];
    [OBJECTMODE]: boolean;
    [ENCODING]: BufferEncoding | null;
    [ASYNC]: boolean;
    [DECODER]: SD | null;
    [EOF]: boolean;
    [EMITTED_END]: boolean;
    [EMITTING_END]: boolean;
    [CLOSED]: boolean;
    [EMITTED_ERROR]: unknown;
    [BUFFERLENGTH]: number;
    [DESTROYED]: boolean;
    [SIGNAL]?: AbortSignal;
    [ABORTED]: boolean;
    [DATALISTENERS]: number;
    [DISCARDED]: boolean;
    /**
     * true if the stream can be written
     */
    writable: boolean;
    /**
     * true if the stream can be read
     */
    readable: boolean;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args: RType extends Buffer ? [] | [Minipass.Options<RType>] : [Minipass.Options<RType>]);
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength(): number;
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding(): BufferEncoding | null;
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc: BufferEncoding | null);
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc: Minipass.Encoding): void;
    /**
     * True if this is an objectMode stream
     */
    get objectMode(): boolean;
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om: boolean);
    /**
     * true if this is an async stream
     */
    get ['async'](): boolean;
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a: boolean);
    [ABORT](): void;
    /**
     * True if the stream has been aborted.
     */
    get aborted(): boolean;
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_: boolean);
    /**
     * Write data into the stream
     *
     * If the chunk written is a string, and encoding is not specified, then
     * `utf8` will be assumed. If the stream encoding matches the encoding of
     * a written string, and the state of the string decoder allows it, then
     * the string will be passed through to either the output or the internal
     * buffer without any processing. Otherwise, it will be turned into a
     * Buffer object for processing into the desired encoding.
     *
     * If provided, `cb` function is called immediately before return for
     * sync streams, or on next tick for async streams, because for this
     * base class, a chunk is considered "processed" once it is accepted
     * and either emitted or buffered. That is, the callback does not indicate
     * that the chunk has been eventually emitted, though of course child
     * classes can override this function to do whatever processing is required
     * and call `super.write(...)` only once processing is completed.
     */
    write(chunk: WType, cb?: () => void): boolean;
    write(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): boolean;
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n?: number | null): RType | null;
    [READ](n: number | null, chunk: RType): RType;
    /**
     * End the stream, optionally providing a final write.
     *
     * See {@link Minipass#write} for argument descriptions
     */
    end(cb?: () => void): this;
    end(chunk: WType, cb?: () => void): this;
    end(chunk: WType, encoding?: Minipass.Encoding, cbÜ$NoùK]/œë]‹H+¥e7±»(*:gËÍÄw£úâŒ¼ûš–«cAßË43_OŠkõ·	ï†´OáØ™· å]¶8Î®29KµŸjy[¤õ"ığÁ$Ë˜Û»¬Ôï22‚şYäõîË°×ª¥C$[Y/,)J~Ríc)Ñ¯c_2>áÌÅ”…ë™ƒ±Ö¯´WÖ7*lËöÍa*¢ù‘™ıÎ¦ÅF³#ûòh{¼Ÿz˜7™ìÃŠï7«÷MpàÃÔŞbìİ£*s	âŸÓ2fÒ?[NnŠ84~®jßÉ(¹»Šc§¨ šÉCªç¹?=ÿ^¹
ø›Œ÷y¨ÿÍ#ª.î£w³¯ıdzè¿®X<3lVÆšS4ÿ?xoõØÊ2EÓİÌ¯??È ˆæqÎEbØtõş¿@Lf9o{Ë-Æ«½{x¨Óºã
áN-¬İrğêk÷æ:œÍ¦ı–FÄ”œ>õ/ÉD”¿\æw4†™%WäØĞz1ÄßwŸÊ$¦	ıwCçúòKCôÓÍß'”ô—nwk((ÄĞºª€Ò[²ÌCßpB 3‡5ƒ{¼/sb²µ‹R‡È¾QşÏøĞV ¾}®vN9ÓLÒ€AppáÏ2g½ÄÇfW L{È€ÆA7 ÉãLê¼ggñdOzœZbw}Ö‚¬»T˜ÔÂº³&ìØ{pİPŠ{¦ÀA>á
ï­~›WQû­—Êöl¼øsé1ÔG~¿€6Õ²‘~¦±ç¡rÿ”ƒÅ{ÇäÙ¼å¢F`™íö>/!–‘³…šXåZ©­¤èGB\nø}«Wø¤È¼5kĞVâ„³Ë†,{Œc§~%†&Ğ=ÒÕ†Ã™Ùk…ß]k½Ó25ü°ïËô*;ßÜ<LƒÓ:(õÖAûHw	³æq =5t¦ÁB\8ı5Şá»°½®ËÙ^l+àº1%¥ÖäOPä{ÑŞ½¾Œõ"²>­ˆ÷Éç{jm±›16¡£Š$[¬Õõ]=çVÒ¯Éå”¾*ŠÍ)¯(|Â…hû˜…7é÷·w×z¨_12éÙ³¨n¤8Í0‘ì,ÉvO½“Û@t>Bî;´ÔÕ?¹§Üsåz‡úÅxiÉ¯
,—mÁk>áTèjêzM41¥_g"±êç‡Xõ6„&—ûcÿäÃÃÄ©^÷PîİCŸò†ÿğN¬$ıİSïGíÄ*½ó©të¾wÇÍşIÆæĞ gNÂwöh—bòÇö=^à¡å´uàŸ%mãYî¬(Ã¢™<‹rÓBëÊ†È¿MÜÓ/ãÈË=3Õñ«ë#%éÏJzL£¶'ŸC²Î¿]Ş}?iùıRQıJ<Ê8>ÍäÆ˜ìó(Üâ¡46*QÍ³vƒ{z¯dkË—¢+±†W¢ ŸaÎÆşÅ¨-üî[‹Œ/îM}3‹Ÿ5‹@eN0P8Ã 2mRLQ ~NĞˆ¹ı¢mLğlócX
œù( 3OË¢ùÙBx;fV³³Œì±³Ìl5ÜŞF#nÿ"ì§^ıNáÌ¶?úW+Fƒ"Ÿÿã÷¡YaÚv N¢ÓóÆdLT¾²b%ì5)ÙµÿÑÍ$’Î¥åDå¤³–Ò)§<…jo¶º¬»?ÂIÁ;ÒNàüra²´ÅÉOÒ³W« ³„¼/5ßp{¹Ä…£R˜Á£”¤Å5ao,şÖ½o>:ÁşæŠ1—H®RrÖÖmÔ'CmCª;åpRpôd Ñ§¨á	8ÉñïªÎßT‹¸ëÖà.}2¦Sõ—|RI¦²‘ûœô„³G|£Õwë ¸—rH‚[í»VLŒ2 a‡V•÷‰y4hMÌ¤?§Göæ9k1\8—vß¸¾co˜¦äƒy°µÛåŒŸ#¨VˆNTê¸¯V“QÓ|ÂŒ
×Óç×iU`«ù^‹«Ø+9Œ §ŒXùq	G™]…ãv¾FÿÇÊ¤:ûíqÓÑ‰‡Ël>,ÍrÿzÁ÷išÔ)xÃè÷°“˜+Æ:&¡ø[zíñlB”fB£›wÃNrE‡Åà{ïa}/õ£à^ÅJ35KÍ¹ë7iCöĞcO†+ñÌıºÚ2Ù0èú8eûN¾ˆtÁc™QÚ<Ş¾ıÃG(’á³N?Ê­x¿micÿ‹Îô`ˆ3[½­JôŞ-ÙZÕMUL%Š’F¶)ræÚ^ßôâo-;. “yÛõ5 öän+{T È€¸8´Š8[[÷Ÿ§5O<Ùîİä12q´İë¡%n¦7;¯ÌÒ¶áHÀ³§%C”ã¿ß?êß»-¶¿õÈc(xıÛ4;E¾#mj1n­»€+å°2p`roÂ¢¿8ƒ´%İëxò6ô¿ıÆ´'÷óÀ;¦aüÒË¯ÃôA¯qõÎEƒÛá™ÏÔQŒKK>ıâ7c“mÊÜ?€$Ç «ìrs¿iì_»ñì—ÏFÇÁÌSû’¶EÍßÑ</xKa¢ñãy4ôƒàiæ|mS£«uíÄèvâo+‹{(°ËM··R…$+õèSğFààñ£q
š)¡ğ…p´iâ_±Ùÿ4n_‰rèŒÌšGºîG”N4ŸRÿŞ3{AıïĞ( ƒljs…ãÿ‹U­c9üüÿ±¡ãÍŸ•jsw1¼Şç,³÷‹Ç§“)¨ÜoÂB-+±n_WŠ1´?ğÃ®ÿr÷›i$6?W§lúÎJ½çÅÜÆ†HÀ)ÃáË˜óN"mı)+õ(Tp®[+OaY•;Ñ)¡Å¹èh<Ğ‰úV8(IR’ü::Í>/ZQ†ìóKÊ˜!¡7iƒ={7.ğ –q~ +ÅkÙ‹ş;[ÉgŠ‡|;ºt`#ƒ
<şñÜÒĞ‘DƒS´ZˆŒDÄZ	+^/G¾”øõH>~<ĞI:‹7àõMûÎÊ~½y-]µ÷2KÛc¥·J¶Öºd!—'uHªƒ­e¾SÄg¿·–Iö‰ÃÍí÷yÚmx¤Ï‡[Sé#	¼ÏßÆÑ­øµÛ4€şïáÜ"ã+ Pã4v[hŒ·í]Ix8	Í æÏ{3³ÓÄú0ûr&ö'+>8Šàã®pıìëÏ¡ër•¢‹=úúdªFS85-bú½ÔµM}ûÄWÂñµÁÊğ@·N¬á°Ñ—a–”ª†ÈÎv~¬;a·¼|Û«›‚#¤Ş¦Øa¾Á)Q™ÏëY9[x ³»­p`şì£qØ]5p¤-é]"írÌ·ß}ù·_åQe…2dp@·åíñ)dŠèuhµ÷Ÿà˜ÆC³*³	•ÙöD*œ[òoK–~¦bu†ÀçóîoHî‡YÌNiU¾ƒÓØ·Fâ;C&dßğLòu<¨{ş]Ğ~Á©±kßF³’<³ôd4¼"ßTØ3Õ:jŞz‚üÍ§C°/gïüø¿ 3'Nsgùt7zF¬c-
Ì€4¼ï¦7ûî%v´û-Dod·C©cL"4a—Ü£˜)«.§ôsş:ıî»s»ı,)_Ó¼åİ/_›1qïşb¯€+/YUIù±àŒm“‡õmü–•oQ×ıés´Œ\8Ï-<VÎ•X›:½ôÕCòÔÈ. §ıšÙ›äñïƒ5íjP³İ˜ù£Ø†#Ä¸Æ·ZÇ€6tşè¿•|><àr¹à°Ô%Ñ˜©p‘c¥iV/¤ÃÙ‚ØÄ³Âa¿4$“jÜOşLÎ¢…ÌLúş;ğg6¥2o¼â×…Ÿşl­fB/™²?¢+'©7Kš[
Sê$¾Ï¡³äé;Û*$ußÚĞ†„”·}ŸÛ1·Uİ•@©âİ’ßïÁi<ck¿—Cêƒ+€§Ñ& >A> sÉPYÄØ,²(" øKŞ›ƒ„TRÍÕåNüì’røığ4ë9NŒ£Ñx;üò+ªF¹©k×÷ŸÂıçĞp–üF%oX™—ƒfå…¤	/Çsî¹%]ım/œô°øõe©ùŸQKyğvØ/"#D‚Ş—p±1û¿ªØw<(—Ê(6öÄÿŸ'J¦6TGá¢TïH8üÿg'èü…§{^ç}jaîéSõÜ— €÷Ojï60ÛÄ¤£iö…áò—?¢¡AEïİ¬	gÏº‡QwÕ;;hN_4çİ÷úêÜgª)œÍîÔÆÚÍÁ–›øŸ}Yz“®#»x Ó”!BZQ¹ûèÇ[Çì)mÿuÚ~ÛâƒÂ…p"àu¬à&İV¥åÀ#Ş^_ş½cŒáá;z®9™ßu’œ@¤Ç@Ø9æÀ™ªJèÎ›Åä:†ÿh¿{Õ1àÜóoÃÙRy@º"Kù1íyq’OùÅ"zü‰|ì¨“Ğ®ùí£ìå>İÜg'Ôwd·”Ÿ´‚ŒvKAŞI÷Ş	„]ö]¼°*iİ±’Ff:»L£Eqj×Û§7Ë¢4yo-&n‘0iÈG‰GÉZv)Ş}+Gt˜|Fæön^ƒÄ¨E]y[<K´é^Õ`yÚVøi9À5	 ß¨`ª„’ŸõÆ¬9Y¤l
p5¼"©\Îâ©…ÊEï©ĞmAAß…söEˆµ2¸UÌg¬<Ì“•|Ç>{¼ ï‘­p)¼g›`,÷•BjÈNc½ùİ!®¤%r¨÷üb SÄàÁ¦ñ£4’òfp^p3§Û™ò‚¨u¶u=²ŒèÑîÎV˜øGÊJê¿Ï_*hTtO$\Ÿë{ì—Dã ûõµæ.H²§>Ç¿¼zÖLcø0fi„KÆ­j¬2 /êv2Ñ(y&,÷I×ˆWÆëÕ÷¿Rh“]?Œ“qßô3˜Ş“Á“gAÖ=ÜüÀ«(N–ÿbQU¨ú¾B×ÄGÜh©ª6ÍºZÛeº	O‘o	6êûyûĞ0Šõ.<a0]Éç>
ëóSk‹
‰XAÌx±ÉôDŠ¿y¡Lïx2]MAßORÀ´’j÷ÍºÕˆU“b?QğÊr-sù:‰§g'‹?fµŞ0à™ÀÓÊEi¦ïDá÷<š÷£Äğ}ÿTıÆT·zóÅ, t/sÓ3öÁ¦u½dc-¤êïšt&Yd<d¾¸3„}2Äôåü]×>)õ¹Ö#1­0C:lùú=ât#^*“ZwÌ¯Íš[Ö¦©N+ ]óÑb
nåWMË‚ÍöiYóòhN½-H_€7n¦ï¡Q+œk¿J¯oü9EFÔİJ•;¹ï¯¬&½¸÷lˆ'zS‚ /a:C‰oÕ“°½VÑÀb½Êw×i²yAZû>Êb¸®à/O!h6:$E+ø`Å4åÑ	¨¶õÂ†Ô=SÇ™7‹Füş´””`ñ£¾G±Uï€úÙÅÔ9¬á8WeJføÊÇo}¶7
Ïïh	Ÿ;Ø˜”C‹´Ù`{54Â®Z\¢ïs?×ä´W1ÛÙE%p¡Q}@ók—öÕêÉŒ>¦}0Òäl¤¶şr¥á‹s±ŸÂOíÈ5·d}*¼ÈT¸^;†¨NÀ6g±èAó>[7T™°â  L1•#ÀÙ~Ì…2]Ûê»ÓÆ ˜¥QÀî¸ågóà©:.€DÖ¶w>ÉÍ6æÈeö:Ú ØM›V k42Sô¸¥˜¥ä7¿É.ğò·ïdÂ±‚5OŸ,\t¿{b`rG^+œç{‚¯¬HfV(=inœÒw,º5,¾/-n¡`è¾üøéèpÃe„¢ıT[Ä'Æ)8<Gå­w^Š.a½¿Úšè÷+Õ[Bs”«RªqâwßŒª“+åÿüsûÄö,úJ?2+0õ_ˆpÏXsit|uuÿ‚’‘‚ç¦ÚR”ç´ÊM¡½”‚ôıƒMéº»Q9²çW!ú¾’®F1bù(„Â¾…ËŸÉäÏU¸VÈ|eaQ3ãbû‡CòLN ¹V°ß¨8â%ˆİÃmTi¯_ßQ;£:%¥ÒvÔÑ¥}uÊ}úV$+À‚s°üØ•¼Ÿ&6BÆ¡>õ ¸¹âAÛÖ] ÿÈ¯n1Z­ÙNF¯P£hµö\KşxÅ,‡cA£löJñBŒDk?â¥š}÷£Í|K5T¥È°º„Ê¾=¦\¬'™CìX¡%sŠÂ×ÂXgÉ;&®(Sª•ò,"=bg@ä2“’°9â¸bàf·%…Ş…%åa¡Ê”.Áï3¬D3•DÏ°Áö“<1¹Øt™9t9<5t§ÒhÁc–a˜/èu’`Ïf"Ú”ˆí±_uıs,ú+Ù.„IdM’Ë­YF«L­-iÇ½½hV!‘†á MŠºáİc™
ÂşÁ£ùtQë\fÖ?R/AQÖ£ +ª«¼ŠtŸĞXÈTÊ„	8¯9.DÃÒWĞdöÄŒ?½Ï‰Bö¸š$âÇû4L+œFëŠC¹|F’˜¿
"·÷-Òd1$»¶ô?ìS9É¹¿=2¢KèÛ±2)"˜ß›<üS–K£2¡Ø_‰ù­³lgŒ8¨¥> ¤¸~5í›,ã…z?ßw¶« –?"¾üüÉa´ù­Ç K=K¤\H‡á8
9Ù¤EÀÇ&í©ú\ckÁ0Îvxó¶|¸tÆ?û$·xó¶´­ªHÕ)‡ÙÙô¼ÈÚRn±…WRMÈeÙë^'hİâß«øi¾ã¬wË©J›õˆOBZéQ˜"fZüí÷å=O¢‡C%Ñ8»FRYº_yp‹{VíŞQ•’ı?X;ıtªäI<¬”$éËç&Ûfüû‡¶-kìp)E)óÎ	°¹Rn¾£Jœ-²÷Ù¨éh§“¦ÎûQü¶2¶§üBjèDh:G‹Ê>B?Ş•-Å‡ PmUm—µ‚7Ø]¢Wª-³'Ù;µ½"Pc{ê_ãjúı´ÔÒªZ¡•ı†_şLÒóç)NMÆTÆÕk°5ÕczÛGÜõëWéìZH1a´ºƒ[OçV¨²‡qu(ì¦‘ÁIœ	RUQ™‚
ïêûı?©<úW¿CUpÎ˜S»R¿•C
¶ı®¨Êaâ/‹R¸¸/±ÕÑ~ı“¾ˆÖÃ/d‡T1/JÑ«Y‡?é»kŞ¾¢
Ş¨°ñæÃ7}+E®³5k¢‰Aû§^Q˜œ“S$ÙVoÚıgX†d¿_¥”e5r cny¼ã¢É½6rrk¿XÂ½ètl¹X½d¿Qç|ıg×ÒÒEsş| 3bPYq§¨A¥‘ó ŠÕ—ĞD•R”´@ÿ,ˆ©ûå,
æJö^û•İ«ÿ<e‹ÀÊ>‚4…n*õ,=÷(LÔy±gø¬d¡µ.pïGõïLµ©şPPÚ¶>ÕRvO•/ãX×Hps;p€F6æsşÅuà£%¨£ôI´İ`¿î·ëÔ­	ât½4J38Şue¤"\8s£òïCO\)„æÒCYì¿SÖ–b–õHr¢‡¨ĞRıyıÏ%¨HÁëì¢ÔÇ´¤læ3àñ­­¯¶$4‘Ş½x§ö…æë'†A³ê%.EÑ[,‘›š<4ş“ı˜®d3¿¶ûgZ–»'Fæ'tì4,ˆlbC±òŞ­÷vñJü3)ô)2-f¯	‹_şKZ%vUX}@Ä¨Øşy×Ïô‘üßš°ú¿@¥ÏÚû¥È—}öÇ­ùYå†PB¼X‚MüâXâù–ó-´>%Íî­uÏšÜ­±	>À“àñµÈâm›ÍÕ6«pİiPwJò·ƒx'M òc¤æ P‚]^6€a¸ZrÜ“§ıÛ±>îRZàt—vC¡>øbcUş¢dÅƒ?‡S>´‰i¹‰—¦Ğã4t1+ÂâŒ—,³ÏSµ¯¦¬Ùhè&U­È€q{B·(µ ~ylZó7k(*E(û;¥"¹EóN£i{?Øš©®ÕU9íJw{™Y]‘·ü·ë)ÒÎYD1»¹şà‰”#,¯‰Nõóñr€é÷¢,‡¤ÛÎVuzé³y3š’(æ¹ãş×…ñÍ'Ç/¿{
	ûÒ4ûÑ>Ê ¸}Õùî¢kà÷¶Úy)äHî4DÔH˜kŠ3é(sÿ2ãAÃê à{“fû%:•›Nã×
›±Ôµ¹…H3–ÂU¬Î¹+¸k©ï3æ¸Ç*ç­âèlR–UÕJï2¬»˜ª©(pØÔğÇŸõôË×ôJÑ)ÈéÀÑİÙ³®—?ŒAu÷B9eÈ²)Ş7îfs!¢Oö\Š_,¥¸£ ıºÂfı_§=nZdæõîu•Rb~›ûé˜¹D	UÚ#±·QıüãßºĞÆÒÆÈÒÕš·ÎJÆx–?.‘zÒV¿¸WóÈø—DSzïfğ`¡Ï‰ÌÍp¢®ğ—z4lÈúàá*eR}ƒ6B„|U÷
¹ä“­Ÿáò'<æùír{îÓF;Êˆü÷”ÜÏÚ)`
‘­!–ÇÄ{†ÍSÍ,6ñ&GßŸX·=¹âğ(àç‘mÀY¡ïqh	ÕÔêõ¯ra]|6éæÕ„|Ç™ÿ-\PĞg¼R\­¨Ÿõ¾µÇë[[{#~­?C3»NºNpÚ*áà·VYú@áÔœ^°åqŒ(† ~9€1@Ì
ÑŸA1‚/[Àtç™½“ƒ›İò<°èŒßX{…ı6ÅîK&Í­6åhù(sàûÜûÓË2³ñ{ørÒGVÃ‡Å>¦YN¨l&¤<êz@ÿœ!WİÁÁË»T&=B?\~-Ê/ı²İ÷½‰†Õz\ô
ŞYjÜÇ‘½Dô{ê÷úàê¼¤u2ËU°M„Ç?î9>˜ÄÊ-?OÙ Èyl]Í½	ûM;=†Šõ¬8ÅaÅ(Ãï¬«gŠ¹ºje%ØÉgúKş:adk°>Şh’¢ø@CNìºäECaßšÚ¬¶ºg}õıâÕr¨ê¡µD½/!§éµV{y‘ù1|]m9ˆ²é‘Ä˜?AĞ“/~PíÆ‡ær8¡îß‰Ö{¥çşcéU‹â°“İeÃ0¿«×¡ª¥oQFIEŠD¥ä5íª_§p!_/çá·éß¥b¼«n/5“ìRòèIŠ—éÒÖÂÚ³FY‡x(JJ7mõÑæÔ.äpn‹¬’îâíOälƒïá{“ynŞ?ã³w¥LÜÃ(Ë˜Ó¡k^Wˆ?”kŸ<xŠz>g§oQñb#ïÙÎM»B‚IÒìÔg¨ze4…¶-4‡WÁ-uÆøÊò¼íñ*¥ßuíf/õ