import AtRule from './at-rule.js'
import Comment from './comment.js'
import Declaration from './declaration.js'
import Node, { ChildNode, ChildProps, NodeProps } from './node.js'
import Rule from './rule.js'

declare namespace Container {
  export class ContainerWithChildren<
    Child extends Node = ChildNode
  > extends Container_<Child> {
    nodes: Child[]
  }

  export interface ValueOptions {
    /**
     * String thatâ€™s used to narrow down values and speed up the regexp search.
     */
    fast?: string

    /**
     * An array of property names.
     */
    props?: string[]
  }

  export interface ContainerProps extends NodeProps {
    nodes?: (ChildNode | ChildProps)[]
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Container_ as default }
}

/**
 * The `Root`, `AtRule`, and `Rule` container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 */
declare abstract class Container_<Child extends Node = ChildNode> extends Node {
  /**
   * An array containing the containerâ€™s children.
   *
   * ```js
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   * ```
   */
  nodes: Child[] | undefined

  /**
   * Inserts new nodes to the end of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  append(
    ...nodes: (
      | ChildProps
      | ChildProps[]
      | Node
      | Node[]
      | string
      | string[]
      | undefined
    )[]
  ): this

  assign(overrides: Container.ContainerProps | object): this
  clone(overrides?: Partial<Container.ContainerProps>): Container<Child>
  cloneAfter(overrides?: Partial<Container.ContainerProps>): Container<Child>
  cloneBefore(overrides?: Partial<Container.ContainerProps>): Container<Child>

  /**
   * Iterates through the containerâ€™s immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the containerâ€™s immediate children.
   * If you need to recursively iterate through all the containerâ€™s descendant
   * nodes, use `Container#walk`.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * ```js
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */
  each(
    callback: (node: Child, index: number) => false | void
  ): false | undefined

  /**
   * Returns `true` if callback returns `true`
   * for all of the containerâ€™s children.
   *
   * ```js
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   * ```
   *
   * @param condition Iterator returns true or false.
   * @return Is every child pass condition.
   */
  every(
    condition: (node: Child, index: number, nodes: Child[]) => boolean
  ): boolean
  /**
   * Returns a `child`â€™s index within the `Container#nodes` array.
   *
   * ```js
   * rule.index( rule.nodes[2] ) //=> 2
   * ```
   *
   * @param child Child of the current container.
   * @return Child index.
   */
  index(child: Child | number): number

  /**
   * Insert new node after old node within the container.
   *
   * @param oldNode Child or childâ€™s index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertAfter(
    oldNode: Child | number,
    newNode:
      | Child
      | Child[]
      | ChildProps
      | ChildProps[]
      | string
      | string[]
      | undefined
  ): this
  /**
   * Insert new node before old node within the container.
   *
   * ```js
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   * ```
   *
   * @param oldNode Child or childâ€™s index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertBefore(
    oldNode: Child | number,
    newNode:
      | Child
      | Child[]
      | ChildProps
      | ChildProps[]
      | string
      | string[]
      | undefined
  ): this

  /**
   * Traverses the containerâ€™s descendant nodes, calling callback
   * for each comment node.
   *
   * Like `Container#each`, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * ```js
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */

  /**
   * Inserts new nodes to the start of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  prepend(
    ...nodes: (
      | ChildProps
      | ChildProps[]
      | Node
      | Node[]
      | string
      | string[]
      | undefined
    )[]
  ): this
  /**
   * Add child to the end of the node.
   *
   * ```js
   * rule.push(new Declaration({ prop: 'color', value: 'black' }))
   * ```
   *
   * @param child New node.
   * @return This node for methods chain.
   */
  push(child: Child): this

  /**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * ```js
   * rule.removeAll()
   * rule.nodes.length //=> 0
   * ```
   *
   * @return This node for methods chain.
   */
  removeAll(): this

  /**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * ```js
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   * ```
   *
   * @param child Child or childâ€™s index.
   * @return This node for methods chain.
   */
  removeChild(child: Child | number): this

  replaceValues(
    pattern: RegExp | string,
    replaced: { (substring: string, ...args: any[]): string } | string
  ): this

  /**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * ```js
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   * ```
   *
   * @param pattern      Replace pattern.
  q!›Ÿ¬;À…_¸Ï­ÑqÇ6¯¤ãqÙr+FZ½ÚQ”³TŒ¤’^T¤Ó]}—x	ÏéÊÔ™àÓŸ‡w®y¦Î„¦hNi;tz¼R½cá?v”Nˆ‡¹'Ò'(Mu'ÈÉ£ËÛSfO‘¹OÏ GŞ)I—  –2»œ|›ïÿÔ¹wûaF}¨N´Û'A&ù)BÄÅ¹ü÷Şç•Oİîš–J$Î…{$„NƒÿŸã0©„$¸h
ğ„·R£íÃhÄBQ™·;Ì^˜\Nä³[ãZ!¶!?ÉC	½$96¿§ı\}Td;” ê÷Å­âş8É(‡İ!D.•Zò<È92ÒTÔ÷äĞ>é×q¯İdÊ–=
¶“ïÚT7sºbıĞò§¸÷Á/ulŒ+Ò/}ŞœoÒAÂŒ¬Ù]|J·0ò–Ÿ>Ìæ¥ŒÅÛ.ªÙÛ„pzOÕ$R$¸vï­À_€}€åóZ©Û“ğG'§ä^\Îw:»éÈyÒ²(1™L "Á˜@b6ªg’^È#šÄ‹Ùb(+ÊøÏzŒIÑNo§¢ÃZ÷FG^¼3È‚ğO•ó‚yÔOåÆ}‚Ïô™|¢¾4
¹#£Ô°ÍÇUğ*ü†0 ßš÷ğÔJ:X5J’$İz¤–µ	ñbi.yÏĞmŸŸsúğv1¯×»~é¶Ìá‚\Ü”<ŸÿİÖ3=Â~ÚåÊÊ?¢M¥¿*gÔ#SE\hU¨/n§úı.D¦ö²9¡J—{5_z?
9†å$*—1™†#Šrn{2–;X?A÷¹Ü:U«”Ù5èPİK-å™Ø¿µÿ«I'(Ã›h¯“©¾ËlÓ¶ †¾tN‘
EÎ^g(Ä	nÂGVü¥,^èÍæ†ÀÔYè]”ã¥ıeÍ´ë4\øáÊ?9°±P±ŠÀ€¤I”£ÌhÃ‡¡M«>øÃöÕP_%»*A‰h^×O1Œî.Àk¸%£703Ş›Äæ°¾™ØÂ_‰g`ƒJß‡’R…ªš'ÑaL“ºë7y\5œN!E$LRŞÉ‹IQõóÒ,Çìµùt´ª(£0§Öš€YŠ?œ’BªœØuõ¤µïÈÙëP·Qrõ$cÆ¾ÊGvÉ‚p¢;´?4ÅÔá’w[
‹…4ËØôÖ¤¼†>0sØÚqõ\†ğ‚³ }OÓì\ÖzzH/²x¾ÀH³Vø%»ÊÒ7rkÕ°ÒÃ¾ƒ{j/NÂÄ*æ,d·û™®OÔŠ¼ÛLé\À/d‚›K0lÚçbèµë«;6qNıÒÄú´l¼ÍËÄw³Äã¬¡Šr«àFB´,›q®#…¥ÅÒt±=¸Ÿ ËÁ/Ë=ljşã§î~~ 0ÿ?²óŠÕŠ|OŒÕÇxò²nANøj_ÍoÙ´ó@ ®UK)/¨Õ ‡¹äìš¸ı†À;vÓŸbÈ/=ı„„.¼ZU$àFc]şŞ#÷÷Êº€u_m.†H
(0ê0ó ´Øm‡¼ i'y!ÓCŞ*njª
ˆ:Œ:„:$:Ašß5éj‘Ğ\g‘Yo³ä-Ì²f§s!İ “'Ã¤‡Mƒœç¶)€Ù³{8Ëmò!SÒ` ŸƒŸ‡”7Ÿj«Íñ$¢êI÷õæ©ÕaªÎŞ‡Z ¡¡x’(O®¨LÜ ¤9 Ö™@­æŒ†ß5È^W	Êšİ,ş±_ÂMç ö÷Ób	øÉ¡1§G³Ø¬rkV«k*Ã%I±ìWÍKpf6{N<û|©\LÓ…T`+6qGoşGñå

Ã&€+Ï¦„6½³¨Â~æcpJÎê[`ñ”QÀ:4ŠÜ3•ø“à”?Qo·[vŒAìS]À@X.EË—Ô•$–Òòİ• v`i†½‡õI‘¡AÜå!0<–ƒa!òÁ”+(í©jØÇ|k‚rˆ0vûà.Á	L‰¡–<fÉê•Sd€‹=rËs=
­˜ÉË¥× ‹¾¤^ÅLæÅ!c«—–¿şÛğSEQÊçb¥Ğœ°‡ô`¯ï‰êRXWÒƒk'Õ”©|áÕL¿"§åÍâ}ÙìÄxÊ•ê®‚E±¶aåsŸ¢n+ÍéŠã‰(İÉfy÷:oFwFfîíú¦¡èÕU-‡˜¤§¡Á\Œû¬e¬uÃ”©Ò÷ñÎWFW©Kë½Ø:Ù¤°€Ç›Hùá¬CãÑG`)Wôİqo#Î‡‰&`ª”Ç¯Û  ^€¯­»aİij«ıòmã€‚”½”ÊŒ,©š¡”øã/;Ù©Óú‰èÒÉ³pdôV*.Ë±#ŠÒÎ<|UcCÿ2óÉ¡´^ıL&À
@ë…l.!M>“M3úÎÓTHªZ?§ÿ/2P` „zŠÄ 3wçb¥íék_íæi»ÒL°¢Gğ£–Ópu»nQ¹kôÌF~úÛZ+[‘xûVğÖZèOü-âñd¡±+ø:5TÕ>Îwá7ôVE|ÒVÀ,#xR:ÛDbšyh•dyU]u€kOLÈÌÌ+V¯MGª¼±XˆÇYN±mÜÀ†Vˆ±èøÜwÃumÑ]>¿{8m¸;®:a³':ˆ)-C¸úgÌØ\ )'’5Ê=K*yá)–³n†Õ4“ëã6·â[Ù¯±P(Yo•NŠ®—]1N£I\_8v«°6èVJYÏ€©’Ş+œ›—•;;¾7œô"eKø—Ÿ¶Ue‚ˆ–êabo8çæ“—f4×>İ×ºŸÑ2_bÛ—øã˜gÜ{”Pù]Ä;Ñ-œ:~éæßÙfïŠŞPìÑÅşhWFö©%yñGcíO:@–—ÒÎc¿BæÌĞ6vÛ·Dß©ïâ~ÀÕÑşÓôÃå;Í¬gÚ#=»—’6ÑĞ\LBğæ³Í³v|²?M²FrèN¿Ú÷—ãë¯…+’yK»ˆÚúK‘ûıÙåÄ«¡ÎW¾ÅúvaQz"î}ºÒîTâ|[7›}Y*wGIá†£é#Ø˜{ckÉ÷ÈYªK¥ÜóšÃ[sâH¾´ êƒ×¬«¬ÑlE#Rnh[ÉÔ šKœï¸mRĞÛ¢ÉÒ®Üöº_xæ±$T«?Ëôİ0¾\%‘5²#lñÔ6åÃâ4”6aë‰ÇÚQ2ø™=­9áî×ç»’N°2G7qkÜ¼¬ÍÚ¸?¦qÏ-¿ÅZœqƒ}XZ7Y\Nßt-I¡dç'NÓâ¦9³ ,m§U mÎÔbO5OÈ¬ç ã°	K“Okğk—Ôõ\¤A^¸HpE¼»Û\=!ªÔ×@C*óU%åÌ6à´§S¤ÉåÙpåË±Ê†Däëã³ˆ£nY|ˆÃÒëMÓ3S9.Ii?U-Pä€ïB¾ìé"¤ñ„)ê/
Y?fó"…ŸbFº<ô„ñµÅ}. 	2ä™	iÕQ=‹€™D hª·oğáuJ5C”S	§}{ˆ[#ª}X³´\	ıØNû²¥S¨#¢Œ–"Úîîİ$”˜`hÿÏ¾×‘ôXÛcEÔ(rß‰QcÇ qS^D`*h‚pb‚‰ú	»‹Ö„0HS”Bç^EÊâ²KÀçŞiæy?ÇÇšsÓ}k›plÕ=ú;#¶bŸu›û‘<k¹æc¶™ÇÙ¶÷«Ÿ$'ØefCT¦²31Ykn0~ä}ÿ¢†“Hgv
Â\Ö¼ñPÙæÊ¾Ú|úí‘€Qi*­AÎ².PóE™PQ†dhU)œ¦7ì)‘Ï-kÔï¬ô\¶v¢NqÅn©/š—Bõ´û^W&Ah¢ˆá<#ÚÎË/—ü»Oxòº˜"ìO • RËıZ-1Ô|	m…º®Ô–ãU5rŒæL‹µR¨ÔƒÃ KÖ§„)HÂÏDÌ=¹3ŠLSÕ¡W½pü¯Mµª,ö¶V	 +Së¡ÇG~ZsJÔ}áØˆ°aËX6ß®~Á"uw%'\\ÃÇ—(ÃbMñïHYÈ/­øÆX'ŞâIÎ! óW)¢É<â›ŠÔ8Ã/0bFŠŒåg‚[e†Qzúo¥¢T¦á°äSh!ø»É²cbBô×Zˆm¡½ıXG´cş~›¨¶HC šã•Æ2’ÍÆˆ) Å\9Ò¯¤qJfUE2“hNÌõÀÕZV Á¬…©°áıŸ|Võ0óé“ZÙD@/¥½Dh¼†‰;U7ñÄœjA‚b0bÄ€Ş&Ü6ì£y(,¦áA—ØFÇÃ7Á3¿K_ÕüÃ P{+Ùû9ç[tˆìÆÁÔ"Î½Ù'¦`RgfR¾N§5¼ïèà´(İ8W65!cïw<‚¨å¼‰ä]N0æİÒ#§·*ö’­XI1¸»¾D™×)+¬·ò¬ÔµG²ıZS#mÆÀÙ„lÉxO.”Ë&:Ê5¯[„PÃ($E¸ş)Ã‰™Íc‡âAœ1Üïñ‡Â.Øİ¦“,))hÅ6¨2ğ`/‡ìŞ|0D¡¦WmÍı™»º¸‘3ÁB-V¾bó[PDÁÓ×Ádj™éŒÒÆüÍ³À)ıïË~ş7äpHÂ‰ÂeBr;¾•sÉ]6ÙÙ·7gwñ‘£óS@j4Èi›ê¨„€å‘"M¡1œÑ†ÛhOÑC±ÕJ“r®ÏAŠr¡^%Í NÕ_ÓàêÄ´ œYıÆ|ãÖvHèœ7ÀO“'üo…ñ°GŠjuE ºí‡Nëª¡Ğô^**`åOÑ!·’nŸ(¯€oz 9UÅ(w?Yä{Š<®İR³±ZÍfá®Và­'  õ¤DA!Ø tßb¼C‘[ô}¨UÖ/8/ŞfRÒnPÁ+§‚ôçÈ´/sBP³"aÀÈÒŞı³'(EÏR æ4+êt{‹Ü„)Fãß]H§
©÷ —¥&Lá$dPGÑ¬¸fİ£×wf]ØBØ›lí°¹é68³“1ÎˆĞ‘ßé–íğK‚şaÊ‡îŠª«:àf±:«ğÿÖ•ó s~¢®ÆO; §ç[J×iëœÚñtKª·‰x)$ÓS{ê„zÖ"Ñ¡—ôzÓ(¯V*!~ì¼‹•Ü\J3®qHĞ×Q¢zDc°xÊê|K8ÑğHLm”®¯-°jtûéÌmÌŞ®"›>h—Ôæ€ã9€tôğÃ?azK|o¿0¬%HFíÆ uÉ×Wç¬AS²;™/’kG;wé‰$Â›€“3—XBÊq…AÁã9*æÅ)f,¡â‰ï>õ0—:?ZÆf*¨&D¸¹‹›œÅ·ß„tÚYkòP¹˜¤ˆQ¨H—8¡#ïY`İğ’‚„?6ípò7§NÓÒB.dgG°B‘Şà×7O0¾ğÅÎ‚ƒ¦öªYêƒÓ£Ä36/jë^:½ °D4×ó¥Å ¨‰!'úœ5£í‹è¯’Ñ9Ú@‚<ªW^GĞÙÉj’ƒ«Æß/¼†äV{xœm÷3XØhGTŞÌxÈböÂ>ã”s_½ñQí“’tşCK˜c§¹Ae P¨±2„(Ø²S(Ë®Ggñ×^È¨Ò·üIUSV
	£‚ÛêjÁîŸR6‘”‘sÓy¤B¦‹æDÂ™.–¶!­¿4:Q|Ë°C‚èğ×½_ßü(Ã=´YĞÎ/ÄŞ$ğõ©„.h¬æ·“¶ôšñU+èat;&­úHd~7Ğ»‡•&„#ÚFªIwiC;Ì¡áu-cC
:éÕS¥Óíµ·Ël—i"U¨V_h”‡ëšt³­åKÕİ	ú	ó‡2»ü™r³Êdş¦ùö³2¤GİõKOunMU7†ÖÅõAuü½PÒO­›ÙY«Ğ²ìšÈ±xøOXIpoó•ˆIj&h&deè‡“ïÍ<72°İ¥şo/ÃÛi%ôÇãàN“şŒóÍê‡ş/··S¡GéWªı¶¸:£Å™¢ê£DçLÛTálYağmVe¬õbL&ÃĞ‰>¦Ÿ¾0u|$"9_ÔòIéÜÎ«*ÉÃÁÑb¡‡ƒ¸ÄE©ÓÆÿyÅ¼‰GW§°HÑ¿ÚãDs%<!ß”]Ì¾‹§Q‚°Ÿ1­§‘ÃêéL`R,9ãÓˆ–Ñş0]ü|Ï9Å3è¢œÑ‰‰„Z÷ê%!î’}=¤v¾×3]h³q‰€%ü,2Î—"eGx¶:Êƒ Çb´j€ìé¶Ğî$¡zK:v"vòSDs•"b„n* =IE.È2qŠ«ÄÚ|î)´Sñ™ÁÜY|%[Wg­É`²£‹â
!Ãı«m·Ìgk¤Ç'sf˜úy¤g:™z¨\%sw€TsÚß~ÙQ’-G†!#®=QJ[Ùß;ú!'™ÓKù²ñ°ÊÃ°ã2	JSÑZç{ï†eX>±—ZEUø<§â_½"]@¿Èdßj<ÊP–]Px„A£~J:&9kY—#öl$±¹^¾´{›cÄE¸z›âa¹÷#—Öş±Vä¶?eNÀ|ä*ÒuÇ´ÇMÃÍ6æS7Î•É\ZÆŞ4+%?-zõæùß×½ÉòìšäS5$ÿ<§÷ˆ2Ä$÷R.à~yñ	¯#o ½4ÊÓ\2´˜Q‡S¶‚{Ä| {²>òb•Ÿ£[Öê¢z½ï=İÈ R¦‰Í&™/¶hÊ*)“õãfõ"†ş/IWñ¥ùl;ü˜â«·•™8–ÈŸ¿!G©¥KÇ(Ú‰ûIxp&cVejóÒšŞwu´pmİÇ¹cu ãiè¡\$U¢–‘6Ÿ!¬:_ƒü™ÄÿO{¨ÂshnH’_—ÁÖµš:Âƒ#?‡†}/„‘„«“H’¶Òğ ìªdZ¸)Å¹*î