'use strict';

const fs = require('fs');
const sysPath = require('path');
const { promisify } = require('util');
const isBinaryPath = require('is-binary-path');
const {
  isWindows,
  isLinux,
  EMPTY_FN,
  EMPTY_STR,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE,
  EV_ADD,
  EV_ADD_DIR,
  EV_ERROR,
  STR_DATA,
  STR_END,
  BRACE_START,
  STAR
} = require('./constants');

const THROTTLE_MODE_WATCH = 'watch';

const open = promisify(fs.open);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const close = promisify(fs.close);
const fsrealpath = promisify(fs.realpath);

const statMethods = { lstat, stat };

// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

const addAndConvert = (main, prop, item) => {
  let container = main[prop];
  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }
  container.add(item);
};

const clearItem = cont => key => {
  const set = cont[key];
  if (set instanceof Set) {
    set.clear();
  } else {
    delete cont[key];
  }
};

const delFromSet = (main, prop, item) => {
  const container = main[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main[prop];
  }
};

const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;

/**
 * @typedef {String} Path
 */

// fs_watch helpers

// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */
const FsWatchInstances = new Map();

/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */
const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], (listener) => {
    listener(val1, val2, val3);
  });
};

/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
  const {listener, errHandler, rawEmitter} = handlers;
  let cont = FsWatchInstances.get(fullPath);

  /** @type {fs.FSWatcher=} */
  let watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
    );
    if (!watcher) return;
    watcher.on(EV_ERROR, async (error) => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      cont.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (isWindows && error.code === 'EPERM') {
        try {
          const fd = await open(path, 'r');
          await close(fd);
          broadcastErr(error);
        } catch (err) {}
      } else {
        broadcastErr(error);
      }
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

// fs_watchFile helpers

// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();

/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
  const {listener, rawEmitter} = handlers;
  let cont = FsWatchFileInstances.get(fullPath);

  /* eslint-disable no-unused-vars, prefer-destructuring */
  let listeners = new Set();
  let rawEmitters = new Set();

  const copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = undefined;
  }

  /* eslint-enable no-unused-vars, prefer-destructuring */

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options,
      watcher: fs.watchFile(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter) => {
          rawEmitter(EV_CHANGE, fullPath, {curr, prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener) => listener(path, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

/**
 * @mixin
 */
class NodeFsHandler {

/**
 * @param {import("../index").FSWatcher} fsW
 */
constructor(fsW) {
  this.fsw = fsW;
  this._boundHandleError = (error) => fsW._handleError(error);
}

/**
 * Watch file for changes with fs_watchFile or fs_watch.
 * @param {String} path to file or dir
 * @param {Function} listener on fs change
 * @returns {Function} closer for the watcher instance
 */
_watchWithNodeFs(path, listener) {
  const opts = this.fsw.options;
  const directory = sysPath.dirname(path);
  const basename = sysPath.basename(path);
  const parent = this.fsw._getWatchedDir(directory);
  parent.add(basename);
  const absolutePath = sysPath.resolve(path);
  const options = {persistent: opts.persistent};
  if (!listener) listener = EMPTY_FN;

  let closer;
  if (opts.usePolling) {
    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?
      opts.binaryInterval : opts.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener,
      rawEmitter: this.fsw._emitRaw
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener,
      errHandler: this._boundHandleError,
      rawEmitter: this.fsw._emitRaw
    });
  }
  return closer;
}

/**
 * Watch a file and emit add event if warranted.
 * @param {Path} file Path
 * @param {fs.Stats} stats result of fs_stat
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @returns {Function} closer for the watcher instance
 */
_handleFile(file, stats, initialAdd) {
  if (this.fsw.closed) {
    return;
  }
  const dirname = sysPath.dirname(file);
  const basename = sysPath.basename(file);
  const parent = this.fsw._getWatchedDir(dirname);
  // stats is always present
  let prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return;

  const listener = async (path, newStats) => {
    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
    if (!newStats || newStats.mtimeMs === 0) {
      try {
        const newStats = await stat(file);
        if (this.fsw.closed) return;
        // Check that change event was not fired because of changed only accessTime.
        const at = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at || at <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV_CHANGE, file, newStats);
        }
        if (isLinux && prevStats.ino !== newStats.ino) {
          this.fsw._closeFile(path)
          prevStats = newStats;
          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
        } else {
          prevStats = newStats;
        }
      } catch (error) {
        // Fix issues where mtime is null but file is still present
        this.fsw._remove(dirname, basename);
      }
      // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      const at = newStats.atimeMs;
      const mt = newStats.mtimeMs;
      if (!at || at <= mt || mt !== prevStats.mtimeMs) {
        this.fsw._emit(EV_CHANGE, file, newStats);
      }
      prevStats = newStats;
    }
  }
  // kick off the watcher
  const closer = this._watchWithNodeFs(file, listener);

  // emit an add event if we're supposed to
  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
    if (!this.fsw._throttle(EV_ADD, file, 0)) return;
    this.fsw._emit(EV_ADD, file, stats);
  }

  return closer;
}

/**
 * Handle symlinks encountered while reading a dir.
 * @param {Object} entry returned by readdirp
 * @param {String} directory path of dir being read
 * @param {String} path of this item
 * @param {String} item basename of this item
 * @returns {Promise<Boolean>} true if ^LĞK6‹MÔQ¬ìCzAá€ZG¡t¹]L„<T¾qFa´/Ì´ë(CÑƒz(ÅQkØº@‘Hmÿ¨8l•:eéô‚J‰‘4şÀÕ>P#Ê¸”ÄLŞg´[¬)cŠûßñ7ùL?³oúÍ>óÏâ³ü¬^Ñn^w6’PF8¯Qqƒã¸`2pÉDƒÚ•”²0aäaIe\ßçş±„%3çXÿxÿ€e¯ßÊ;0([üÍ/[t;‹hèßNÍ éıìlTN9DÛì(¸ÑíÙş[óK…Æñ4=F#Û=ÚÊ4ŸL²dõr{ì=M‹ÈøâTÕqy8~hWÛ¯nÅ0Ì¿²‹¶©°¸êÃh—eÕ|8à¢mÌM^wÙ i…æÍ¤y2ìï²şe/T{Y¡	AîE˜+0,'ìıİ\§r8Z/L[=¨å•G° 3 ¨Ÿ‰è6ÙDÛ´$oóª¸›Á«6p´]˜«!$İæ­óğÏ½
Ê/ÔDÆdVØ4/OM¬}·±Ü4«iãêAÀÆæåcmn>7·8¨¢lIUÍmu2ª4–óîmıä
tó…Mr“ÙdK&Á›Ïø­^_HNš5õ<M[X÷Î®|­µÀ øËæ]ÎyS5¶@J•qVØM‹ZsFÜğú€|ÿï©ã©0)Ú\¶ñëV¡°¯Ûûû‹…¼ë‡ãÍü©XÊ.ÎÚ€dyw¢á¹eáu]ºöƒÅÛÛÇ/Ü~r‘i^@Uä¤ü}üÏ+Kße}I_œ–‰çVÎñ~±çı DïX_ŸU`1±ŞejHğNX_D@qñ9'Æyûr(æ`âƒHòYYß¸ç Ø†IğOˆ_&$”PÆ€V]ÕÖôŸx¬ü¾•­–C$U	,2 uı~‰>j@m{·òÖŞZü[ÙÊ¯$ŠIT³–~şZ|«ó=œØ859°•øøÄ¥€îX?êÅû&d¹æèù7gYº›Tc‚ªås¤^ìòõm€åaâ	{0ÇßïèwEB‹”È'‡<²,g4?úJÊQ|†ÑWˆÌ‚r	×i°î:Ä1‹(!Éij\r">bÀÚÍ®– µ ]Ìkƒ)ÔáwFøNšLå^5–óí€‹éÂ‹wxôb´³¯ü˜€‹áBÅµ×bÁHŒ_0¦A7[šz®ñjP»Çò”
ôòë6û„e°~fÔªŠ³|ÌNANü¢Šæôx&rçLOÆz²)ªûKH¯?¯¨Q 2µ½Ií =ş³ FXïÑbeÑI€·n2=ÜŠòåÂÂ+Z-ôb$B6€à”,FÅVùeìïvé|^ºPb^Ÿ­à½e†fÏŠœÏÊËóí°e,4 Z.†±€u±0ÜXeÃTe¬¯3"ëËc1ĞMÒâf”>k$H<@@õƒ¢l)ê#I†E0*"´ç’a Ü“Cì¶i`S »U‡Àñâ"“#¨‘gs[¡Çyì>: IÇÚhñØ œ,¸1 Dg‹ ¼™Š &>¼yÚ$œ$†(s°Fá!Æ Pd/dÈpAsÂD ùLyóÀ€€âş‹D B{«	HODÓ' /Š l -å±ª&p^×|• æF€kA5±Ë\Ô«Á©Ôòáš>q£:¸G	2È—÷hÙ¢Ïe´€@åİø£4Ûg´@ED£GŒXYŒµ`F rxãz`¤ÄFõ5`@ˆod¿Q	óÆ50ÀN¨F<b ˜£	ASê¤£ PT™í¨‚€Ç¸®¹*hà°m¢~£
¡Éq":šËm`Ôaà(GF¼qo|oAëÌ£ş}±I[Å''f-b©ëTN±€	æ½cã“’‹[YÕBj[–ôâFIÅU+sRY˜4ÅÀ¸TóZ„'W#]õ¶„‚‰+F)5‰QËqQpÏ>oÑŠ†–yäºÚÇ«kW;0Ùü:¯›Ct“LZk¨«$›–¥òÖ‰ÆGû"…±J²©İĞ‰<vĞĞvv{‹b§9˜x-x”Fô“9P8¿X&ô<¥ á;œŒ<#¶vª^§£İ.F±W¬ rA•|€u M#®M(¢èÄÌ”&Á¸ô=Œï_û\ÑF`Ş¨(Ğ/`‚ÆÃdÓ©…sbts4pB‚ÍµdÆ¦Y|–† ù×ºçÇ¤¢¨Xº¶MÑ,?&Ó¥jè‘ãõšÙéwì€ó!J5„›l1·jã5Ò‹E$MY4ìúŞƒ‰ƒ3*6˜|‹tÆ¹‰VcÓt@#»*J`ü¡kÄíˆÃ¡1«Ûùæ‘Î8—:«™ü[™=1!’5çdÂ$ªoĞŒüzİÂ±4b›PT/U´.¹„H©%´hêŸSÉt$GCÈè~õÅx5ä(O&‰^Ó8|Y±¨Øg?£voT3¥3ª©ı1R°×4­t»¬´Ëõæv¦ÂcMØ§¼
¼‚±˜T´O= “¶BıJšAóª»`ûµ·ÓÕçĞE0Sõµò4:%·*5€n‡´¦ÅµñÈrÁ¸¹]0âŠZ{ŠGö_$U)´GE¦aºU†ƒ‡e§šñ¤0ô™Vñ)Z†êèVÀâ`<Ì`E‹u´XˆeÛŠ ±„{päæ‰¼f¢X¢RŒ¨“68ŞÉ…7ÂÄtÄˆ&kÄÀ‚o'¢¼±%€ åÁğü·BGN …;Q1 B ¢Çä±1˜Á†ÖüqçbnÂm]yğãŠı*Ö„¤ºŞ,ˆZJàA`2òi,13Å `  ›!Œ_˜÷Ş8Ê–Ï7*,ŠÀÀY8AÂş¨J›FW3ÆS&¤%Ä=à8'ùùoQ:[²ôõABñ2<
°½ıjE7Oà;›‹CtSè#:ú…ló} <j ö‘•àU^	4ÉJJ‚ÿâ‚ßc6{$7î=Ñ%(ÁäâXÉÚ|¡Ñåày…ã%¸¶d#ÉsïA8˜×Î¨)ërR™æ¤º7òU	\Ëc	á"¢„À×ìEäí,ö¶ãº)G³±ŸP6/‹|^»—×Ë¥öH½æ//
ïºö(ïÈ/MeùlJ4ÂJHz}_£ßÌhF/(·$'™m`ÊÜş¾íî)
2½MİfôĞİJVsÿHú¢0á>1Q¾©¨™èÆrFöe­›[Ü0C+«t[­'êpÃ_&ˆá²]_h×<hë„©šq´¬4L6İŸa®¡p¸Õ,¦Ğª).ÄY¥JèÎ`¹aĞ$*9{<mÆc³që‡Îe06»ŒÇLû×½î '³Pè‹qœ†Ö½™õlR¢•ù+ÁÂ"¸œ–®èÈğ­AÂ|‚)2Ù8N­Ôr`XYßĞçaVs™X<X>XYÙ”­ŠX[Ù^cS[™ØYÙi-Á#îù˜¤Ltt <@}Ğ{€ö ÿ`ğ`ø ıÉ²ï/#4GØ^¤="öˆÚg3Òó{Ä<H<H>H=bqÒ2rŠJÊÔ >h<h>È?(<âTTÔ´´ŸÈ9\s¾ó¨yôœßœÿ\À\à\Ğî9àçğÌáÃ7™Ã?ÇÍãç	óÕ<Ñ^ğ<i<G`.d2:O¯çiöÚ§Ï7s3å Ç±)èî„TŸ€¹¦èËÃÍI”ó¤ºşv€«ºÈ.öc
XWbusÍÔ·uƒñ¿Y\2HrvaZÇjØ×]]Ø4‚UcX4Y“0k
ÀE([Kı®<+'İ…h,HU»„ÊÅ€Ó#°ü.Ğ×&0] ÃñÂç<C¤ÿ…j-#V®Uw*³2åá{øø³¾pfw>[8óèœ.4†RÈCÕVÖ€#8MhÕ’Eù("~ˆ Qª(tÎ{À	9Y¼ªF ›²şxV›b°ıñ)+’@Ø"÷ÿŞ]`Q^uâZ|•§Û† †ˆš×EDQørÊ?¦ 
ºĞ´ÒqÓÚ»W yı“	0eÎqÃ µ­H½GëÆÒî¸Õ–D÷Zw»°‡¹U9cT ÖcîöàĞw«r7Jİ§2U ³nN&a¡ÅKü‘=\l~\jKt¼ËdÓ0Ö­²xäNvbj™b.ê\/°YÓ:zZ„ƒB&aÉİ€4¦ GQÅ>¡;\]øåá(Ÿ¢$ş<'0ÒTªbQ•‰ŞƒÉƒåƒq|÷^ ÷<= y{ˆz²k…­‡hø.$·9Ä-[ıÍìl±S€é iÀ*6ÉÍl†œèlñÓdag‚{ÆVkdlr:ü§4ÓÙP`ùm™d€UËŒ‚$ÕöRÅKmšoBî3?gLB=UFi›*&œf(6¥Û*Êúc0>ÕìMš´„íf:ôæÇÈ-àÉÔtàj_²bw©³®[³5ÅÜÊrÇÅ"'lXæp'V9<¿™)ÖV“yÅ±Ù5häggŠ­••{)>7ÅÎÊškiÌìà¶Ë~Àb‡úÚ+ú°m
0Jşˆ)~ñ•'ÃSx3‘%SÂˆÕkNû3"ìÈ 6Èhô ÀÃôğóg "€: ô{‚~‡’ÌZ•E30!úc˜u4€Ç¬{‡¢ÓG½B¨V%^¹@ü=î%	>ÃônÀè}I¿õGu1$ó–¢¤õ"Y®HéGyà$¥v9Ô4P» ¹05ööZ à‚%T¨DD’<*LUnb—Á@å9°O¡fk@Bì‚éåYÁm¨‘ÖtF›İI•f æÒáI†ˆCİ$UıÊó=ävYæL˜­½ iÇÃ¤È\ŒŠleÄ+ÕERïÔ{˜bÌ÷ÁrÑMÑ`-Tƒö  ìñ0¼a(ôJ)ò…#İMHX>à”p]–1t 0Äâ2§ì‘ä$˜mîÙXBñ‰å‹ß÷ÒÊÛbjÆÁv2fnVë<¡ÃäMoÓ1Îã`õæêíR*³«mŞI0Ewœı³RfêäÎUVğ_ 
¼	ÆVØÑˆàFd+sEà1©,àJ˜4ü‘pe™‹'†qbüL¹˜„£DoªÊ#kÖïŠ&üL§c~QKGo{™;Z
ˆ¥OXôyoºœ{ÛVtæ8ã»JZ–„¥‡·[…,¡az, wh, realpath) {
  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
  const tracked = parentDir.has(sysPath.basename(dir));
  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
  }

  // ensure dir is tracked (harmless if redundant)
  parentDir.add(sysPath.basename(dir));
  this.fsw._getWatchedDir(dir);
  let throttler;
  let closer;

  const oDepth = this.fsw.options.depth;
  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
    if (!target) {
      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
      if (this.fsw.closed) return;
    }

    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
      // if current directory is removed, do nothing
      if (stats && stats.mtimeMs === 0) return;

      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
    });
  }
  return closer;
}

/**
 * Handle added file, directory, or glob pattern.
 * Delegates call to _handleFile / _handleDir after checks.
 * @param {String} path to file or ir
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @param {Object} priorWh depth relative to user-supplied path
 * @param {Number} depth Child path actually targeted for watch
 * @param {String=} target Child path actually targeted for watch
 * @returns {Promise}
 */
async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
  const ready = this.fsw._emitReady;
  if (this.fsw._isIgnored(path) || this.fsw.closed) {
    ready();
    return false;
  }

  const wh = this.fsw._getWatchHelpers(path, depth);
  if (!wh.hasGlob && priorWh) {
    wh.hasGlob = priorWh.hasGlob;
    wh.globFilter = priorWh.globFilter;
    wh.filterPath = entry => priorWh.filterPath(entry);
    wh.filterDir = entry => priorWh.filterDir(entry);
  }

  // evaluate what is at the path we're being asked to watch
  try {
    const stats = await statMethods[wh.statMethod](wh.watchPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(wh.watchPath, stats)) {
      ready();
      return false;
    }

    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);
    let closer;
    if (stats.isDirectory()) {
      const absPath = sysPath.resolve(path);
      const targetPath = follow ? await fsrealpath(path) : path;
      if (this.fsw.closed) return;
      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
      if (this.fsw.closed) return;
      // preserve this symlink's target path
      if (absPath !== targetPath && targetPath !== undefined) {
        this.fsw._symlinkPaths.set(absPath, targetPath);
      }
    } else if (stats.isSymbolicLink()) {
      const targetPath = follow ? await fsrealpath(path) : path;
      if (this.fsw.closed) return;
      const parent = sysPath.dirname(wh.watchPath);
      this.fsw._getWatchedDir(parent).add(wh.watchPath);
      this.fsw._emit(EV_ADD, wh.watchPath, stats);
      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
      if (this.fsw.closed) return;

      // preserve this symlink's target path
      if (targetPath !== undefined) {
        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
      }
    } else {
      closer = this._handleFile(wh.watchPath, stats, initialAdd);
    }
    ready();

    this.fsw._addPathCloser(path, closer);
    return false;

  } catch (error) {
    if (this.fsw._handleError(error)) {
      ready();
      return path;
    }
  }
}

}

module.exports = NodeFsHandler;
